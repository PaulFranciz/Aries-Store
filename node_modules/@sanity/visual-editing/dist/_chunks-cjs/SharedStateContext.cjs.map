{"version":3,"file":"SharedStateContext.cjs","sources":["../../src/react/useOptimistic.ts","../../../../node_modules/.pnpm/uuid@11.0.3/node_modules/uuid/dist/esm-browser/stringify.js","../../../../node_modules/.pnpm/uuid@11.0.3/node_modules/uuid/dist/esm-browser/rng.js","../../../../node_modules/.pnpm/uuid@11.0.3/node_modules/uuid/dist/esm-browser/native.js","../../../../node_modules/.pnpm/uuid@11.0.3/node_modules/uuid/dist/esm-browser/v4.js","../../src/util/geometry.ts","../../src/util/dragAndDrop.ts","../../src/util/elements.ts","../../src/util/stega.ts","../../src/util/findSanityNodes.ts","../../src/ui/shared-state/SharedStateContext.ts","../../src/controller.ts"],"sourcesContent":["import type {SanityDocument} from '@sanity/types'\nimport {startTransition, useEffect, useState} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport {isEmptyActor} from '../optimistic/context'\nimport type {OptimisticReducer, OptimisticReducerAction} from '../optimistic/types'\nimport {getPublishedId} from '../util/documents'\nimport {useOptimisticActor} from './useOptimisticActor'\n\nexport function useOptimistic<T, U = SanityDocument>(\n  passthrough: T,\n  reducer: OptimisticReducer<T, U> | Array<OptimisticReducer<T, U>>,\n): T {\n  const [pristine, setPristine] = useState(true)\n  const [optimistic, setOptimistic] = useState<T>(passthrough)\n  const [lastEvent, setLastEvent] = useState<OptimisticReducerAction<U> | null>(null)\n  const [lastPassthrough, setLastPassthrough] = useState<T>(passthrough)\n\n  const actor = useOptimisticActor()\n\n  /**\n   * This action is used in two `useEffect` hooks, it needs access to the provided `reducer`,\n   * but doesn't want to cause re-renders if `reducer` changes identity.\n   * The `useEffectEvent` hook ensures that the `reducer` value is never stale when used, and doesn't trigger setup and teardown of\n   * `useEffect` deps to make it happen.\n   */\n  const reduceStateFromAction = useEffectEvent(\n    (action: OptimisticReducerAction<U>, prevState: T) => {\n      const reducers = Array.isArray(reducer) ? reducer : [reducer]\n      return reducers.reduce(\n        (acc, reducer) =>\n          reducer(acc, {\n            document: action.document,\n            id: getPublishedId(action.id),\n            originalId: action.id,\n            type: action.type,\n          }),\n        prevState,\n      )\n    },\n  )\n\n  /**\n   * Records the last passthrough value when reducers ran in response to a rebased event.\n   * This allows us to later know when reducers should run should the passthrough change.\n   */\n  const updateLastPassthrough = useEffectEvent(() => setLastPassthrough(passthrough))\n\n  /**\n   * Handle rebase events, which runs the provided reducers,\n   * caches the event that was used to produce the new state,\n   * and marks the state as non-pristine.\n   */\n  useEffect(() => {\n    // If the actor hasn't been set yet, we don't need to subscribe to mutations\n    if (isEmptyActor(actor)) {\n      return\n    }\n\n    /**\n     * The pristine event fires much too soon, so the temporary workaround is that we greatly delay firing `setPristine(true)`,\n     * and instead relying on re-running reducers with the last event whenever the passthrough changes, to preserve the optimistic state,\n     * until we hopefully have eventual consistency on the passthrough.\n     */\n    let pristineTimeout: ReturnType<typeof setTimeout>\n\n    const rebasedSub = actor.on('rebased.local', (_event) => {\n      const event = {\n        // @todo You shall not cast\n        document: _event.document as U,\n        id: _event.id,\n        originalId: getPublishedId(_event.id),\n        // @todo This should eventually be emitted by the state machine\n        type: 'mutate' as const,\n      }\n      setOptimistic((prevState) => reduceStateFromAction(event, prevState))\n      setLastEvent(event)\n      updateLastPassthrough()\n      setPristine(false)\n\n      clearTimeout(pristineTimeout)\n    })\n    const pristineSub = actor.on('pristine', () => {\n      pristineTimeout = setTimeout(() => {\n        // Marking it in a startTransition allows react to interrupt the resulting render, should a new rebase happen and we're back to dirty\n        startTransition(() => setPristine(true))\n      }, 15000)\n    })\n    return () => {\n      rebasedSub.unsubscribe()\n      pristineSub.unsubscribe()\n    }\n  }, [actor, reduceStateFromAction, updateLastPassthrough])\n\n  /**\n   * If the passthrough changes, and we are in a dirty state, we rerun the reducers with the new passthrough but the previous event.\n   * Marking it in a transition allows react to interrupt this render should a new action happen, or should we be back in a pristine state.\n   */\n  useEffect(() => {\n    if (pristine) {\n      // if we are pristine, then we will passthrough anyway\n      return undefined\n    }\n    if (!lastEvent) {\n      // If we don't have a lastEvent when we are pristine, it's a fatal error\n      throw new Error('No last event found when syncing passthrough')\n    }\n    if (lastPassthrough === passthrough) {\n      // If the passthrough hasn't changed, then we don't need to rerun the reducers\n      return undefined\n    }\n\n    // Marking it in a startTransition allows react to interrupt the resulting render, should a new rebase happen\n    startTransition(() => {\n      setOptimistic(reduceStateFromAction(lastEvent, passthrough))\n      setLastPassthrough(passthrough)\n    })\n  }, [lastEvent, lastPassthrough, passthrough, pristine, reduceStateFromAction])\n\n  return pristine ? passthrough : optimistic\n}\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || rng)();\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import type {OverlayRect, Point2D, Ray2D} from '../types'\n\nexport function getRect(element: Element): OverlayRect {\n  const domRect = element.getBoundingClientRect()\n\n  const rect = {\n    x: domRect.x + scrollX,\n    y: domRect.y + scrollY,\n    w: domRect.width,\n    h: domRect.height,\n  }\n\n  return rect\n}\n\nexport function offsetRect(rect: OverlayRect, px: number, axis: 'x' | 'y'): OverlayRect {\n  if (axis === 'x') {\n    return {\n      x: rect.x + px,\n      y: rect.y,\n      w: rect.w - 2 * px,\n      h: rect.h,\n    }\n  } else {\n    return {\n      x: rect.x,\n      y: rect.y + px,\n      w: rect.w,\n      h: rect.h - 2 * px,\n    }\n  }\n}\n\n// Ref http://paulbourke.net/geometry/pointlineplane/\nexport function rayIntersect(l1: Ray2D, l2: Ray2D): Point2D | false {\n  const {x1, y1, x2, y2} = l1\n  const {x1: x3, y1: y3, x2: x4, y2: y4} = l2\n\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false\n  }\n\n  const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return false\n  }\n\n  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator\n  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return false\n  }\n\n  const x = x1 + ua * (x2 - x1)\n  const y = y1 + ua * (y2 - y1)\n\n  return {x, y}\n}\n\nexport function rectEqual(r1: OverlayRect, r2: OverlayRect): boolean {\n  return r1.x === r2.x && r1.y === r2.y && r1.w === r2.w && r1.h === r2.h\n}\n\nexport function rayRectIntersections(line: Ray2D, rect: OverlayRect): Array<Point2D> | false {\n  const rectLines: Array<Ray2D> = [\n    {x1: rect.x, y1: rect.y, x2: rect.x + rect.w, y2: rect.y},\n    {\n      x1: rect.x + rect.w,\n      y1: rect.y,\n      x2: rect.x + rect.w,\n      y2: rect.y + rect.h,\n    },\n    {\n      x1: rect.x + rect.w,\n      y1: rect.y + rect.h,\n      x2: rect.x,\n      y2: rect.y + rect.h,\n    },\n    {\n      x1: rect.x,\n      y1: rect.y + rect.h,\n      x2: rect.x,\n      y2: rect.y,\n    },\n  ]\n\n  const intersections: Array<Point2D> = []\n\n  for (let i = 0; i < rectLines.length; i++) {\n    const intersection = rayIntersect(line, rectLines[i])\n\n    if (intersection) {\n      let isDuplicate = false\n\n      for (let j = 0; j < intersections.length; j++) {\n        if (intersections[j].x === intersection.x && intersections[j].y === intersection.y) {\n          isDuplicate = true\n        }\n      }\n\n      if (!isDuplicate) intersections.push(intersection)\n    }\n  }\n\n  if (intersections.length === 0) {\n    return false\n  }\n\n  return intersections.sort(\n    (a, b) => pointDist(a, {x: line.x1, y: line.y1}) - pointDist(b, {x: line.x1, y: line.y1}),\n  )\n}\nexport function pointDist(p1: Point2D, p2: Point2D): number {\n  const a = p1.x - p2.x\n  const b = p1.y - p2.y\n\n  return Math.sqrt(a * a + b * b)\n}\n\nexport function pointInBounds(point: Point2D, bounds: OverlayRect): boolean {\n  const withinX = point.x >= bounds.x && point.x <= bounds.x + bounds.w\n  const withinY = point.y >= bounds.y && point.y <= bounds.y + bounds.h\n\n  return withinX && withinY\n}\n\nexport function findClosestIntersection(\n  ray: Ray2D,\n  targets: OverlayRect[],\n  flow: string,\n): OverlayRect | null {\n  const rayOrigin = {\n    x: ray.x1,\n    y: ray.y1,\n  }\n\n  // Offset rects to ensure raycasting works when siblings touch\n  if (\n    targets.some((t) =>\n      pointInBounds(\n        rayOrigin,\n        offsetRect(t, Math.min(t.w, t.h) / 10, flow === 'horizontal' ? 'x' : 'y'),\n      ),\n    )\n  )\n    return null\n  let closestIntersection\n  let closestRect\n\n  for (const target of targets) {\n    const intersections = rayRectIntersections(\n      ray,\n      offsetRect(target, Math.min(target.w, target.h) / 10, flow === 'horizontal' ? 'x' : 'y'),\n    )\n    if (intersections) {\n      const firstIntersection = intersections[0]\n\n      if (closestIntersection) {\n        if (pointDist(rayOrigin, firstIntersection) < pointDist(rayOrigin, closestIntersection)) {\n          closestIntersection = firstIntersection\n          closestRect = target\n        }\n      } else {\n        closestIntersection = firstIntersection\n        closestRect = target\n      }\n    }\n  }\n\n  if (closestRect) return closestRect\n\n  return null\n}\n\nexport function scaleRect(\n  rect: OverlayRect,\n  scale: number,\n  origin: {x: number; y: number},\n): OverlayRect {\n  const {x, y, w, h} = rect\n  const {x: originX, y: originY} = origin\n\n  const newX = originX + (x - originX) * scale\n  const newY = originY + (y - originY) * scale\n\n  const newWidth = w * scale\n  const newHeight = h * scale\n\n  return {\n    x: newX,\n    y: newY,\n    w: newWidth,\n    h: newHeight,\n  }\n}\n\nexport function getRectGroupXExtent(rects: OverlayRect[]): {\n  min: number\n  max: number\n  width: number\n} {\n  const minGroupX = Math.max(0, Math.min(...rects.map((r) => r.x)))\n  const maxGroupX = Math.min(document.body.offsetWidth, Math.max(...rects.map((r) => r.x + r.w)))\n\n  return {\n    min: minGroupX,\n    max: maxGroupX,\n    width: maxGroupX - minGroupX,\n  }\n}\n\nexport function getRectGroupYExtent(rects: OverlayRect[]): {\n  min: number\n  max: number\n  height: number\n} {\n  const minGroupY = Math.max(0, Math.min(...rects.map((r) => r.y)))\n  const maxGroupY = Math.min(document.body.scrollHeight, Math.max(...rects.map((r) => r.y + r.h)))\n\n  return {\n    min: minGroupY,\n    max: maxGroupY,\n    height: maxGroupY - minGroupY,\n  }\n}\n","import type {\n  DragInsertPosition,\n  DragInsertPositionRects,\n  ElementNode,\n  OverlayElement,\n  OverlayEventHandler,\n  OverlayRect,\n  Point2D,\n  SanityNode,\n} from '../types'\nimport {\n  findClosestIntersection,\n  getRect,\n  getRectGroupXExtent,\n  getRectGroupYExtent,\n  pointDist,\n  rectEqual,\n  scaleRect,\n} from './geometry'\n\nfunction calcTargetFlow(targets: OverlayRect[]) {\n  if (\n    targets.some((t1) => {\n      const others = targets.filter((t2) => !rectEqual(t1, t2))\n\n      return others.some((t2) => {\n        return t1.y === t2.y\n      })\n    })\n  ) {\n    return 'horizontal'\n  } else {\n    return 'vertical'\n  }\n}\n\nfunction calcInsertPosition(origin: Point2D, targets: OverlayRect[], flow: string) {\n  if (flow === 'horizontal') {\n    const rayLeft = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x - 100_000_000,\n      y2: origin.y,\n    }\n\n    const rayRight = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x + 100_000_000,\n      y2: origin.y,\n    }\n\n    return {\n      left: findClosestIntersection(rayLeft, targets, flow),\n      right: findClosestIntersection(rayRight, targets, flow),\n    }\n  } else {\n    const rayTop = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x,\n      y2: origin.y - 100_000_000,\n    }\n\n    const rayBottom = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x,\n      y2: origin.y + 100_000_000,\n    }\n\n    return {\n      top: findClosestIntersection(rayTop, targets, flow),\n      bottom: findClosestIntersection(rayBottom, targets, flow),\n    }\n  }\n}\n\nfunction findRectSanityData(rect: OverlayRect, overlayGroup: OverlayElement[]) {\n  return overlayGroup.find((e) => rectEqual(getRect(e.elements.element), rect))\n    ?.sanity as SanityNode\n}\n\nfunction resolveInsertPosition(\n  overlayGroup: OverlayElement[],\n  insertPosition: DragInsertPositionRects,\n  flow: string,\n): DragInsertPosition {\n  if (Object.values(insertPosition).every((v) => v === null)) return null\n\n  if (flow === 'horizontal') {\n    return {\n      left: insertPosition.left\n        ? {\n            rect: insertPosition.left,\n            sanity: findRectSanityData(insertPosition.left, overlayGroup),\n          }\n        : null,\n      right: insertPosition.right\n        ? {\n            rect: insertPosition.right,\n            sanity: findRectSanityData(insertPosition.right, overlayGroup),\n          }\n        : null,\n    }\n  } else {\n    return {\n      top: insertPosition.top\n        ? {\n            rect: insertPosition.top,\n            sanity: findRectSanityData(insertPosition.top, overlayGroup),\n          }\n        : null,\n      bottom: insertPosition.bottom\n        ? {\n            rect: insertPosition.bottom,\n            sanity: findRectSanityData(insertPosition.bottom, overlayGroup),\n          }\n        : null,\n    }\n  }\n}\n\nfunction calcMousePos(e: MouseEvent) {\n  const bodyBounds = document.body.getBoundingClientRect()\n\n  return {\n    x: Math.max(bodyBounds.x, Math.min(e.clientX, bodyBounds.x + bodyBounds.width)),\n    y: e.clientY + window.scrollY,\n  }\n}\n\nfunction calcMousePosInverseTransform(mousePos: Point2D) {\n  const body = document.body\n  const computedStyle = window.getComputedStyle(body)\n  const transform = computedStyle.transform\n\n  if (transform === 'none') {\n    return {\n      x: mousePos.x,\n      y: mousePos.y,\n    }\n  }\n\n  const matrix = new DOMMatrix(transform)\n  const inverseMatrix = matrix.inverse()\n\n  const point = new DOMPoint(mousePos.x, mousePos.y)\n  const transformedPoint = point.matrixTransform(inverseMatrix)\n\n  return {\n    x: transformedPoint.x,\n    y: transformedPoint.y,\n  }\n}\n\nfunction buildPreviewSkeleton(mousePos: Point2D, element: ElementNode, scaleFactor: number) {\n  const bounds = getRect(element)\n\n  const children = [\n    ...element.querySelectorAll(':where(h1, h2, h3, h4, p, a, img, span, button):not(:has(*))'),\n  ]\n\n  if (mousePos.x <= bounds.x) mousePos.x = bounds.x\n  if (mousePos.x >= bounds.x + bounds.w) mousePos.x = bounds.x + bounds.w\n\n  if (mousePos.y >= bounds.y + bounds.h) mousePos.y = bounds.y + bounds.h\n  if (mousePos.y <= bounds.y) mousePos.y = bounds.y\n\n  const childRects = children.map((child: Element) => {\n    // offset to account for stroke in rendered rects\n    const rect = scaleRect(getRect(child), scaleFactor, {\n      x: bounds.x,\n      y: bounds.y,\n    })\n\n    return {\n      x: rect.x - bounds.x,\n      y: rect.y - bounds.y,\n      w: rect.w,\n      h: rect.h,\n      tagName: child.tagName,\n    }\n  })\n\n  return {\n    offsetX: (bounds.x - mousePos.x) * scaleFactor,\n    offsetY: (bounds.y - mousePos.y) * scaleFactor,\n    w: bounds.w * scaleFactor,\n    h: bounds.h * scaleFactor,\n    maxWidth: bounds.w * scaleFactor * 0.75,\n    childRects,\n  }\n}\n\nconst minDragDelta = 4\n\nasync function applyMinimapWrapperTransform(\n  target: HTMLElement,\n  scaleFactor: number,\n  minYScaled: number,\n  handler: OverlayEventHandler,\n  rectUpdateFrequency: number,\n): Promise<void> {\n  return new Promise((resolve) => {\n    target.addEventListener(\n      'transitionend',\n      () => {\n        setTimeout(() => {\n          handler({\n            type: 'overlay/dragEndMinimapTransition',\n          })\n        }, rectUpdateFrequency * 2)\n\n        resolve()\n      },\n      {once: true},\n    )\n\n    handler({\n      type: 'overlay/dragStartMinimapTransition',\n    })\n\n    handler({\n      type: 'overlay/dragToggleMinimap',\n      display: true,\n    })\n\n    document.body.style.overflow = 'hidden'\n    document.body.style.height = '100%'\n    document.documentElement.style.overflow = 'initial'\n    document.documentElement.style.height = '100%'\n\n    // ensure overflow hidden has applied and scrolling stopped before applying transform, prevent minor y-position transform issues\n    setTimeout(() => {\n      target.style.transformOrigin = '50% 0px'\n      target.style.transition = 'transform 150ms ease'\n      target.style.transform = `translate3d(0px, ${-minYScaled + scrollY}px, 0px) scale(${scaleFactor})`\n    }, 25)\n  })\n}\n\nfunction calcMinimapTransformValues(rects: OverlayRect[], groupHeightOverride: number | null) {\n  let groupHeight = groupHeightOverride || getRectGroupYExtent(rects).height\n\n  const padding = 100 // px\n\n  groupHeight += padding * 2\n\n  const scaleFactor = groupHeight > window.innerHeight ? window.innerHeight / groupHeight : 1\n  const scaledRects = rects.map((r) => scaleRect(r, scaleFactor, {x: window.innerWidth / 2, y: 0}))\n\n  const {min: minYScaled} = getRectGroupYExtent(scaledRects)\n\n  return {\n    scaleFactor,\n    minYScaled: minYScaled - padding * scaleFactor,\n  }\n}\nfunction calcGroupBoundsPreview(rects: OverlayRect[]) {\n  const groupBoundsX = getRectGroupXExtent(rects)\n  const groupBoundsY = getRectGroupYExtent(rects)\n\n  const offsetDist = 8\n\n  const canOffsetX =\n    groupBoundsX.min > offsetDist &&\n    groupBoundsX.min + groupBoundsX.width <= window.innerWidth - offsetDist\n  const canOffsetY =\n    groupBoundsY.min > offsetDist &&\n    groupBoundsY.min + groupBoundsY.height <= document.body.scrollHeight - offsetDist\n  const canOffset = canOffsetX && canOffsetY\n\n  const groupRect = {\n    x: canOffset ? groupBoundsX.min - offsetDist : groupBoundsX.min,\n    y: canOffset ? groupBoundsY.min - offsetDist : groupBoundsY.min,\n    w: canOffset ? groupBoundsX.width + offsetDist * 2 : groupBoundsX.width,\n    h: canOffset ? groupBoundsY.height + offsetDist * 2 : groupBoundsY.height,\n  }\n\n  return groupRect\n}\n\nasync function resetMinimapWrapperTransform(\n  endYOrigin: number,\n  target: HTMLElement,\n  prescaleHeight: number,\n  handler: OverlayEventHandler,\n  rectUpdateFrequency: number,\n  previousRootStyleValues: PreviousRootStyleValues | null,\n): Promise<void> {\n  return new Promise((resolve) => {\n    const computedStyle = window.getComputedStyle(target)\n    const transform = computedStyle.transform\n\n    const matrix = new DOMMatrix(transform)\n\n    const scale = matrix.a\n\n    if (scale === 1) return\n\n    const maxScroll = prescaleHeight - window.innerHeight\n    const prevScrollY = scrollY\n\n    endYOrigin -= window.innerHeight / 2\n\n    if (endYOrigin < 0) endYOrigin = 0\n\n    target.addEventListener(\n      'transitionend',\n      () => {\n        target.style.transition = `none`\n        target.style.transform = `none`\n\n        scrollTo({\n          top: endYOrigin,\n          behavior: 'instant',\n        })\n\n        setTimeout(() => {\n          handler({\n            type: 'overlay/dragEndMinimapTransition',\n          })\n\n          handler({\n            type: 'overlay/dragToggleMinimap',\n            display: false,\n          })\n        }, rectUpdateFrequency * 2)\n\n        resolve()\n      },\n      {once: true},\n    )\n\n    handler({\n      type: 'overlay/dragStartMinimapTransition',\n    })\n\n    target.style.transform = `translateY(${Math.max(prevScrollY - endYOrigin, -maxScroll + prevScrollY)}px) scale(${1})`\n\n    if (!previousRootStyleValues) return\n\n    document.body.style.overflow = previousRootStyleValues.body.overflow\n    document.body.style.height = previousRootStyleValues.body.height\n    document.documentElement.style.overflow = previousRootStyleValues.documentElement.overflow\n    document.documentElement.style.height = previousRootStyleValues.documentElement.height\n  })\n}\n\ninterface PreviousRootStyleValues {\n  body: {\n    overflow: string\n    height: string\n  }\n  documentElement: {\n    overflow: string\n    height: string\n  }\n}\n\ninterface HandleOverlayDragOpts {\n  mouseEvent: MouseEvent\n  element: ElementNode\n  overlayGroup: OverlayElement[]\n  handler: OverlayEventHandler\n  target: SanityNode\n  onSequenceStart: () => void\n  onSequenceEnd: () => void\n}\n\nlet minimapScaleApplied = false\n\nlet mousePosInverseTransform = {x: 0, y: 0}\nlet mousePos = {x: 0, y: 0}\n\nlet prescaleHeight = typeof document === 'undefined' ? 0 : document.documentElement.scrollHeight\n\nlet previousRootStyleValues: PreviousRootStyleValues | null = null\n\nexport function handleOverlayDrag(opts: HandleOverlayDragOpts): void {\n  const {mouseEvent, element, overlayGroup, handler, target, onSequenceStart, onSequenceEnd} = opts\n\n  // do not trigger drag sequence on anything other than \"main\" (0) click, ignore right click, etc\n  if (mouseEvent.button !== 0) return\n\n  // ensure keyboard events fire within frame context\n  window.focus()\n\n  const rectUpdateFrequency = 150\n  let rects = overlayGroup.map((e) => getRect(e.elements.element))\n\n  const flow = (element.getAttribute('data-sanity-drag-flow') || calcTargetFlow(rects)) as\n    | 'horizontal'\n    | 'vertical'\n\n  const dragGroup = element.getAttribute('data-sanity-drag-group')\n\n  const disableMinimap = !!element.getAttribute('data-sanity-drag-minimap-disable')\n\n  const preventInsertDefault = !!element.getAttribute('data-sanity-drag-prevent-default')\n\n  const documentHeightOverride = element.getAttribute('data-unstable_sanity-drag-document-height')\n  const groupHeightOverride = element.getAttribute('data-unstable_sanity-drag-group-height')\n\n  let insertPosition: DragInsertPositionRects | null = null\n\n  const initialMousePos = calcMousePos(mouseEvent)\n\n  const scaleTarget = document.body\n\n  const {minYScaled, scaleFactor} = calcMinimapTransformValues(\n    rects,\n    groupHeightOverride ? ~~groupHeightOverride : null,\n  )\n\n  let sequenceStarted = false\n  let minimapPromptShown = false\n\n  let mousedown = true\n\n  if (!minimapScaleApplied) {\n    previousRootStyleValues = {\n      body: {\n        overflow: window.getComputedStyle(document.body).overflow,\n        height: window.getComputedStyle(document.body).height,\n      },\n      documentElement: {\n        overflow: window.getComputedStyle(document.documentElement).overflow,\n        height: window.getComputedStyle(document.documentElement).height,\n      },\n    }\n\n    prescaleHeight = documentHeightOverride\n      ? ~~documentHeightOverride\n      : document.documentElement.scrollHeight\n  }\n\n  const rectsInterval = setInterval(() => {\n    rects = overlayGroup.map((e) => getRect(e.elements.element))\n  }, rectUpdateFrequency)\n\n  const applyMinimap = (): void => {\n    if (scaleFactor >= 1) return\n\n    const skeleton = buildPreviewSkeleton(mousePos, element, scaleFactor)\n\n    handler({\n      type: 'overlay/dragUpdateSkeleton',\n      skeleton,\n    })\n\n    handler({\n      type: 'overlay/dragToggleMinimapPrompt',\n      display: false,\n    })\n\n    handler({\n      type: 'overlay/dragToggleMinimap',\n      display: true,\n    })\n\n    minimapScaleApplied = true\n\n    applyMinimapWrapperTransform(\n      scaleTarget,\n      scaleFactor,\n      minYScaled,\n      handler,\n      rectUpdateFrequency,\n    ).then(() => {\n      setTimeout(() => {\n        handler({\n          type: 'overlay/dragUpdateGroupRect',\n          groupRect: calcGroupBoundsPreview(rects),\n        })\n      }, rectUpdateFrequency * 2)\n    })\n  }\n\n  const handleScroll = (e: WheelEvent) => {\n    if (\n      Math.abs(e.deltaY) >= 10 &&\n      scaleFactor < 1 &&\n      !minimapScaleApplied &&\n      !minimapPromptShown &&\n      !disableMinimap &&\n      mousedown\n    ) {\n      handler({\n        type: 'overlay/dragToggleMinimapPrompt',\n        display: true,\n      })\n\n      minimapPromptShown = true\n    }\n\n    if (e.shiftKey && !minimapScaleApplied && !disableMinimap) {\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragApplyMinimap'))\n\n      setTimeout(() => {\n        applyMinimap()\n      }, 50)\n    }\n  }\n\n  const handleMouseMove = (e: MouseEvent): void => {\n    e.preventDefault()\n\n    mousePos = calcMousePos(e)\n    mousePosInverseTransform = calcMousePosInverseTransform(mousePos)\n\n    if (Math.abs(pointDist(mousePos, initialMousePos)) < minDragDelta) return\n\n    if (!sequenceStarted) {\n      const groupRect = calcGroupBoundsPreview(rects)\n\n      const skeleton = buildPreviewSkeleton(mousePos, element, 1)\n\n      handler({\n        type: 'overlay/dragStart',\n        flow,\n      })\n\n      handler({\n        type: 'overlay/dragUpdateSkeleton',\n        skeleton,\n      })\n\n      handler({\n        type: 'overlay/dragUpdateGroupRect',\n        groupRect,\n      })\n\n      sequenceStarted = true\n      onSequenceStart()\n    }\n\n    handler({\n      type: 'overlay/dragUpdateCursorPosition',\n      x: mousePos.x,\n      y: mousePos.y,\n    })\n\n    if (e.shiftKey && !minimapScaleApplied && !disableMinimap) {\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragApplyMinimap'))\n\n      setTimeout(() => {\n        applyMinimap()\n      }, 50)\n    }\n\n    const newInsertPosition = calcInsertPosition(mousePos, rects, flow)\n\n    if (JSON.stringify(insertPosition) !== JSON.stringify(newInsertPosition)) {\n      insertPosition = newInsertPosition\n\n      handler({\n        type: 'overlay/dragUpdateInsertPosition',\n        insertPosition: resolveInsertPosition(overlayGroup, insertPosition, flow),\n      })\n    }\n  }\n\n  const handleMouseUp = (): void => {\n    mousedown = false\n\n    handler({\n      type: 'overlay/dragEnd',\n      target,\n      insertPosition: insertPosition\n        ? resolveInsertPosition(overlayGroup, insertPosition, flow)\n        : null,\n      dragGroup,\n      flow,\n      preventInsertDefault,\n    })\n\n    if (minimapPromptShown) {\n      handler({\n        type: 'overlay/dragToggleMinimapPrompt',\n        display: false,\n      })\n    }\n\n    if (!minimapScaleApplied) {\n      clearInterval(rectsInterval)\n      onSequenceEnd()\n\n      removeFrameListeners()\n      removeKeyListeners()\n    }\n\n    removeMouseListeners()\n  }\n\n  const handleKeyup = (e: KeyboardEvent) => {\n    if (e.key === 'Shift' && minimapScaleApplied) {\n      minimapScaleApplied = false\n\n      const skeleton = buildPreviewSkeleton(mousePos, element, 1 / scaleFactor)\n\n      handler({\n        type: 'overlay/dragUpdateSkeleton',\n        skeleton,\n      })\n\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragResetMinimap'))\n\n      setTimeout(() => {\n        resetMinimapWrapperTransform(\n          mousePosInverseTransform.y,\n          scaleTarget,\n          prescaleHeight,\n          handler,\n          rectUpdateFrequency,\n          previousRootStyleValues,\n        )\n      }, 50)\n\n      handler({\n        type: 'overlay/dragUpdateGroupRect',\n        groupRect: null,\n      })\n\n      // cleanup keyup after drag sequence is complete\n      if (!mousedown) {\n        clearInterval(rectsInterval)\n\n        removeMouseListeners()\n        removeFrameListeners()\n        removeKeyListeners()\n\n        onSequenceEnd()\n      }\n    }\n  }\n\n  const handleBlur = () => {\n    handler({\n      type: 'overlay/dragUpdateGroupRect',\n      groupRect: null,\n    })\n\n    window.dispatchEvent(new CustomEvent('unstable_sanity/dragResetMinimap'))\n\n    setTimeout(() => {\n      resetMinimapWrapperTransform(\n        mousePosInverseTransform.y,\n        scaleTarget,\n        prescaleHeight,\n        handler,\n        rectUpdateFrequency,\n        previousRootStyleValues,\n      ).then(() => {\n        minimapScaleApplied = false\n      })\n    }, 50)\n\n    clearInterval(rectsInterval)\n\n    removeMouseListeners()\n    removeFrameListeners()\n    removeKeyListeners()\n\n    onSequenceEnd()\n  }\n\n  const removeMouseListeners = () => {\n    window.removeEventListener('mousemove', handleMouseMove)\n    window.removeEventListener('wheel', handleScroll)\n    window.removeEventListener('mouseup', handleMouseUp)\n  }\n\n  const removeKeyListeners = () => {\n    window.removeEventListener('keyup', handleKeyup)\n  }\n\n  const removeFrameListeners = () => {\n    window.removeEventListener('blur', handleBlur)\n  }\n\n  window.addEventListener('blur', handleBlur)\n  window.addEventListener('keyup', handleKeyup)\n  window.addEventListener('wheel', handleScroll)\n  window.addEventListener('mousemove', handleMouseMove)\n  window.addEventListener('mouseup', handleMouseUp)\n}\n","import type {ElementNode} from '../types'\n\nexport const isElementNode = (target: EventTarget | null): target is ElementNode => {\n  return target instanceof HTMLElement || target instanceof SVGElement\n}\n\nexport function findNonInlineElement(element: ElementNode): ElementNode | null {\n  const {display} = window.getComputedStyle(element)\n\n  if (display !== 'inline') return element\n\n  const parent = element.parentElement\n\n  if (!parent) return null\n\n  return findNonInlineElement(parent)\n}\n\nexport const findOverlayElement = (\n  el: EventTarget | ElementNode | null | undefined,\n): ElementNode | null => {\n  if (!el || !isElementNode(el)) {\n    return null\n  }\n\n  if (el.dataset?.['sanityOverlayElement']) {\n    return el\n  }\n\n  return findOverlayElement(el.parentElement)\n}\n","import type {SanityStegaNode} from '@repo/visual-editing-helpers'\nimport {vercelStegaDecode} from '@vercel/stega'\nimport {VERCEL_STEGA_REGEX} from '../constants'\n\n/**\n * JavaScript regexps are stateful. Have to reset lastIndex between runs to ensure consistent behaviour for the same string\n * @param input\n */\nfunction testVercelStegaRegex(input: string): boolean {\n  VERCEL_STEGA_REGEX.lastIndex = 0\n  return VERCEL_STEGA_REGEX.test(input)\n}\n\nfunction decodeStega(str: string, isAltText = false): SanityStegaNode | null {\n  try {\n    const decoded = vercelStegaDecode<SanityStegaNode>(str)\n    if (!decoded || decoded.origin !== 'sanity.io') {\n      return null\n    }\n    if (isAltText) {\n      decoded.href = decoded.href?.replace('.alt', '')\n    }\n    return decoded\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error('Failed to decode stega for string: ', str, 'with the original error: ', err)\n    return null\n  }\n}\n\nexport function testAndDecodeStega(str: string, isAltText = false): SanityStegaNode | null {\n  if (testVercelStegaRegex(str)) {\n    return decodeStega(str, isAltText)\n  }\n  return null\n}\n","import {decodeSanityNodeData} from '@repo/visual-editing-helpers/csm'\nimport type {\n  ElementNode,\n  OverlayElement,\n  ResolvedElement,\n  SanityNode,\n  SanityStegaNode,\n} from '../types'\nimport {findNonInlineElement} from './elements'\nimport {testAndDecodeStega} from './stega'\n\nconst isElementNode = (node: ChildNode): node is ElementNode => node.nodeType === Node.ELEMENT_NODE\n\nconst isImgElement = (el: ElementNode): el is HTMLImageElement => el.tagName === 'IMG'\n\nconst isTimeElement = (el: ElementNode): el is HTMLTimeElement => el.tagName === 'TIME'\n\nconst isSvgRootElement = (el: ElementNode): el is SVGSVGElement =>\n  el.tagName.toUpperCase() === 'SVG'\n\nexport function isSanityNode(node: SanityNode | SanityStegaNode): node is SanityNode {\n  return 'path' in node\n}\n\n/**\n * Finds commonality between two document paths strings\n * @param first First path to compare\n * @param second Second path to compare\n * @returns A common path\n */\nexport function findCommonPath(first: string, second: string): string {\n  let firstParts = first.split('.')\n  let secondParts = second.split('.')\n  const maxLength = Math.min(firstParts.length, secondParts.length)\n  firstParts = firstParts.slice(0, maxLength).reverse()\n  secondParts = secondParts.slice(0, maxLength).reverse()\n\n  return firstParts\n    .reduce((parts, part, i) => (part === secondParts[i] ? [...parts, part] : []), [] as string[])\n    .reverse()\n    .join('.')\n}\n\n/**\n * Returns common Sanity node data from multiple nodes\n * If document paths are present, tries to resolve a common path\n * @param nodes An array of Sanity nodes\n * @returns A single sanity node or undefined\n * @internal\n */\nexport function findCommonSanityData(\n  nodes: (SanityNode | SanityStegaNode)[],\n): SanityNode | SanityStegaNode | undefined {\n  // If there are no nodes, or inconsistent node types\n  if (!nodes.length || !nodes.map((n) => isSanityNode(n)).every((n, _i, arr) => n === arr[0])) {\n    return undefined\n  }\n  // If legacy nodes, return first match (no common pathfinding)\n  if (!isSanityNode(nodes[0])) return nodes[0]\n\n  const sanityNodes = nodes.filter(isSanityNode)\n  let common: SanityNode | undefined = nodes[0]\n\n  const consistentValueKeys: Array<keyof SanityNode> = [\n    'projectId',\n    'dataset',\n    'id',\n    'baseUrl',\n    'workspace',\n    'tool',\n  ]\n  for (let i = 1; i < sanityNodes.length; i++) {\n    const node = sanityNodes[i]\n    if (consistentValueKeys.some((key) => node[key] !== common?.[key])) {\n      common = undefined\n      break\n    }\n\n    common.path = findCommonPath(common.path, node.path)\n  }\n\n  return common\n}\n\n/**\n * Finds nodes containing sanity specific data\n * @param el - A parent element to traverse\n * @returns An array of objects, each containing an HTML element and decoded sanity data\n * @internal\n */\nexport function findSanityNodes(\n  el: ElementNode | ChildNode | {childNodes: Array<ElementNode>},\n): ResolvedElement[] {\n  const elements: ResolvedElement[] = []\n\n  function addElement(element: ElementNode, data: SanityStegaNode | string) {\n    const sanity = decodeSanityNodeData(data)\n    if (!sanity) {\n      return\n    }\n\n    // resize observer does not fire for non-replaced inline elements https://drafts.csswg.org/resize-observer/#intro\n    const measureElement = findNonInlineElement(element)\n    if (!measureElement) {\n      return\n    }\n\n    elements.push({\n      elements: {\n        element,\n        measureElement,\n      },\n      sanity,\n    })\n  }\n\n  if (el) {\n    for (const node of el.childNodes) {\n      const {nodeType, parentElement, textContent} = node\n      // If an edit target is found, find common paths\n      if (isElementNode(node) && node.dataset?.['sanityEditTarget'] !== undefined) {\n        const nodesInTarget = findSanityNodes(node).map(({sanity}) => sanity)\n        // If there are inconsistent node types, continue\n        if (!nodesInTarget.map((n) => isSanityNode(n)).every((n, _i, arr) => n === arr[0])) {\n          continue\n        }\n\n        const commonData = findCommonSanityData(nodesInTarget)\n\n        if (commonData) {\n          elements.push({\n            elements: {\n              element: node,\n              measureElement: node,\n            },\n            sanity: commonData,\n          })\n        }\n\n        // Check non-empty, child-only text nodes for stega strings\n      } else if (nodeType === Node.TEXT_NODE && parentElement && textContent) {\n        const data = testAndDecodeStega(textContent)\n        if (!data) continue\n        addElement(parentElement, data)\n      }\n      // Check element nodes for data attributes, alt tags, etc\n      else if (isElementNode(node)) {\n        // Do not traverse script tags\n        // Do not traverse the visual editing overlay\n        if (node.tagName === 'SCRIPT' || node.tagName === 'SANITY-VISUAL-EDITING') {\n          continue\n        }\n\n        // Prefer elements with explicit data attributes\n        if (node.dataset?.['sanity']) {\n          addElement(node, node.dataset['sanity'])\n        }\n        // Look for legacy sanity data attributes\n        else if (node.dataset?.['sanityEditInfo']) {\n          addElement(node, node.dataset['sanityEditInfo'])\n        } else if (isImgElement(node)) {\n          const data = testAndDecodeStega(node.alt, true)\n          if (!data) continue\n          addElement(node, data)\n          // No need to recurse for img elements\n          continue\n        } else if (isTimeElement(node)) {\n          const data = testAndDecodeStega(node.dateTime, true)\n          if (!data) continue\n          addElement(node, data)\n        } else if (isSvgRootElement(node)) {\n          if (!node.ariaLabel) continue\n          const data = testAndDecodeStega(node.ariaLabel, true)\n          if (!data) continue\n          addElement(node, data)\n        }\n\n        elements.push(...findSanityNodes(node))\n      }\n    }\n  }\n  return elements\n}\n\nexport function isSanityArrayPath(path: string): boolean {\n  const lastDotIndex = path.lastIndexOf('.')\n  const lastPathItem = path.substring(lastDotIndex, path.length)\n\n  return lastPathItem.includes('[')\n}\n\nexport function getSanityNodeArrayPath(path: string): string | null {\n  if (!isSanityArrayPath(path)) return null\n\n  const split = path.split('.')\n\n  split[split.length - 1] = split[split.length - 1].replace(/\\[.*?\\]/g, '[]')\n\n  return split.join('.')\n}\n\nexport function sanityNodesExistInSameArray(\n  sanityNode1: SanityNode,\n  sanityNode2: SanityNode,\n): boolean {\n  if (!isSanityArrayPath(sanityNode1.path) || !isSanityArrayPath(sanityNode2.path)) return false\n\n  return getSanityNodeArrayPath(sanityNode1.path) === getSanityNodeArrayPath(sanityNode2.path)\n}\n\nexport function resolveDragAndDropGroup(\n  element: ElementNode,\n  sanity: SanityNode | SanityStegaNode,\n  elementSet: Set<ElementNode>,\n  elementsMap: WeakMap<ElementNode, OverlayElement>,\n): null | OverlayElement[] {\n  if (!element.getAttribute('data-sanity')) return null\n\n  if (element.getAttribute('data-sanity-drag-disable')) return null\n\n  if (!sanity || !isSanityNode(sanity) || !isSanityArrayPath(sanity.path)) return null\n\n  const targetDragGroup = element.getAttribute('data-sanity-drag-group')\n\n  const group = [...elementSet].reduce<OverlayElement[]>((acc, el) => {\n    const elData = elementsMap.get(el)\n    const elDragDisabled = el.getAttribute('data-sanity-drag-disable')\n    const elDragGroup = el.getAttribute('data-sanity-drag-group')\n    const elHasSanityAttribution = el.getAttribute('data-sanity') !== null\n\n    const sharedDragGroup = targetDragGroup !== null ? targetDragGroup === elDragGroup : true\n\n    if (\n      elData &&\n      !elDragDisabled &&\n      isSanityNode(elData.sanity) &&\n      sanityNodesExistInSameArray(sanity, elData.sanity) &&\n      sharedDragGroup &&\n      elHasSanityAttribution\n    ) {\n      acc.push(elData)\n    }\n\n    return acc\n  }, [])\n\n  if (group.length <= 1) return null\n\n  return group\n}\n","import {createContext} from 'react'\nimport type {VisualEditingNode} from '../../types'\nimport type {SharedStateStore} from './sharedStateStore'\n\nexport interface SharedStateContextValue {\n  comlink?: VisualEditingNode\n  store: SharedStateStore\n}\n\nexport const SharedStateContext = createContext<SharedStateContextValue | null>(null)\n","import {v4 as uuid} from 'uuid'\nimport type {\n  ElementNode,\n  EventHandlers,\n  OverlayController,\n  OverlayElement,\n  OverlayOptions,\n  ResolvedElement,\n} from './types'\nimport {handleOverlayDrag} from './util/dragAndDrop'\nimport {findOverlayElement, isElementNode} from './util/elements'\nimport {\n  findSanityNodes,\n  isSanityArrayPath,\n  isSanityNode,\n  resolveDragAndDropGroup,\n} from './util/findSanityNodes'\nimport {getRect} from './util/geometry'\n\n/**\n * Creates a controller which dispatches overlay related events\n *\n * @param handler - Dispatched event handler\n * @param overlayElement - Parent element containing rendered overlay elements\n * @public\n */\nexport function createOverlayController({\n  handler,\n  overlayElement,\n  inFrame,\n  optimisticActorReady,\n}: OverlayOptions): OverlayController {\n  let activated = false\n  // Map for getting element by ID\n  const elementIdMap = new Map<string, ElementNode>()\n  // WeakMap for getting data by element\n  const elementsMap = new WeakMap<ElementNode, OverlayElement>()\n  // Set for iterating over elements\n  const elementSet = new Set<ElementNode>()\n  // Weakmap keyed by measureElement to find associated element\n  const measureElements = new WeakMap<ElementNode, ElementNode>()\n  // Weakmap for storing user set cursor styles per element\n  const cursorMap = new WeakMap<ElementNode, string | undefined>()\n\n  const preventDefault = inFrame\n\n  let ro: ResizeObserver\n  let io: IntersectionObserver | undefined\n  let mo: MutationObserver\n\n  let activeDragSequence = false\n\n  // The `hoverStack` is used as a container for tracking which elements are hovered at any time.\n  // The browser supports hovering multiple nested elements simultanously, but we only want to\n  // highlight the \"outer most\" element.\n  //\n  // This is how it works:\n  // - Whenever the mouse enters an element, we add it to the stack.\n  // - Whenever the mouse leaves an element, we remove it from the stack.\n  //\n  // When we want to know which element is currently hovered, we take the element at the top of the\n  // stack. Since JavaScript does not have a Stack type, we use an array and take the last element.\n  let hoverStack: Array<ElementNode> = []\n  const getHoveredElement = () => hoverStack[hoverStack.length - 1] as ElementNode | undefined\n\n  function addEventHandlers(el: ElementNode, handlers: EventHandlers) {\n    el.addEventListener('click', handlers.click as EventListener, {\n      capture: true,\n    })\n    el.addEventListener('contextmenu', handlers.contextmenu as EventListener, {\n      capture: true,\n    })\n    // We listen for the initial mousemove event, in case the overlay is enabled whilst the cursor is already over an element\n    // mouseenter and mouseleave listeners are attached within this handler\n    el.addEventListener('mousemove', handlers.mousemove as EventListener, {\n      once: true,\n      capture: true,\n    })\n    // Listen for mousedown in case we need to prevent default behavior\n    el.addEventListener('mousedown', handlers.mousedown as EventListener, {\n      capture: true,\n    })\n  }\n\n  function removeEventHandlers(el: ElementNode, handlers: EventHandlers) {\n    el.removeEventListener('click', handlers.click as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('contextmenu', handlers.contextmenu as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mousemove', handlers.mousemove as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mousedown', handlers.mousedown as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mouseenter', handlers.mouseenter as EventListener)\n    el.removeEventListener('mouseleave', handlers.mouseleave as EventListener)\n  }\n\n  /**\n   * Executed when element enters the viewport\n   * Enables an element’s event handlers\n   */\n  function activateElement({id, elements, handlers}: OverlayElement) {\n    const {element, measureElement} = elements\n    addEventHandlers(element, handlers)\n    ro.observe(measureElement)\n    handler({\n      type: 'element/activate',\n      id,\n    })\n  }\n\n  /**\n   * Executed when element leaves the viewport\n   * Disables an element’s event handlers\n   */\n  function deactivateElement({id, elements, handlers}: OverlayElement) {\n    const {element, measureElement} = elements\n    removeEventHandlers(element, handlers)\n    ro.unobserve(measureElement)\n    // Scrolling from a hovered element will not trigger mouseleave event, so filter the stack\n    hoverStack = hoverStack.filter((el) => el !== element)\n    handler({\n      type: 'element/deactivate',\n      id,\n    })\n  }\n\n  function setOverlayCursor(element: ElementNode) {\n    // Don't set the cursor if mutations are unavailable\n    if (!inFrame || !optimisticActorReady) return\n\n    // Loops through the entire hoverStack, trying to set the cursor if the\n    // stack element matches the element passed to the function, otherwise\n    // restoring the cursor\n    for (const hoverstackElement of hoverStack) {\n      if (element === hoverstackElement) {\n        const targetSanityData = elementsMap.get(element)?.sanity\n        if (!targetSanityData || !isSanityNode(targetSanityData)) return\n\n        const dragGroup = resolveDragAndDropGroup(\n          element,\n          targetSanityData,\n          elementSet,\n          elementsMap,\n        )\n\n        if (dragGroup) {\n          // Store any existing cursor so it can be restored later\n          const existingCursor = element.style.cursor\n          if (existingCursor) {\n            cursorMap.set(element, existingCursor)\n          }\n\n          handler({\n            type: 'overlay/setCursor',\n            element,\n            cursor: 'move',\n          })\n\n          continue\n        }\n      }\n\n      restoreOverlayCursor(hoverstackElement)\n    }\n  }\n\n  function restoreOverlayCursor(element: ElementNode) {\n    // Restore any previously stored cursor (if it exists)\n    const previousCursor = cursorMap.get(element)\n\n    handler({\n      type: 'overlay/setCursor',\n      element,\n      cursor: previousCursor,\n    })\n  }\n\n  /**\n   * Stores an element’s DOM node and decoded sanity data in state and sets up event handlers\n   */\n  function registerElement({elements, sanity}: ResolvedElement) {\n    const {element, measureElement} = elements\n\n    const eventHandlers: EventHandlers = {\n      click(event) {\n        const target = event.target as ElementNode | null\n\n        if (element === getHoveredElement() && element.contains(target)) {\n          if (preventDefault) {\n            event.preventDefault()\n            event.stopPropagation()\n          }\n\n          const sanity = elementsMap.get(element)?.sanity\n          if (sanity && !activeDragSequence) {\n            handler({\n              type: 'element/click',\n              id,\n              sanity,\n            })\n          }\n        }\n      },\n      contextmenu(event) {\n        if (!('path' in sanity) || !inFrame || !optimisticActorReady) return\n\n        // This is a temporary check as the context menu only supports array\n        // items (for now). We split the path into segments, if a `_key` exists\n        // in last path segment, we assume it's an array item, and so return\n        // early if it is some other type.\n        if (!sanity.path.split('.').pop()?.includes('[_key==')) return\n\n        const target = event.target as ElementNode | null\n        if (element === getHoveredElement() && element.contains(target)) {\n          if (preventDefault) {\n            event.preventDefault()\n            event.stopPropagation()\n          }\n          handler({\n            type: 'element/contextmenu',\n            id,\n            position: {\n              x: event.clientX,\n              y: event.clientY,\n            },\n            sanity,\n          })\n        }\n      },\n      mousedown(event) {\n        // prevent iframe from taking focus\n        event.preventDefault()\n\n        if (event.currentTarget !== hoverStack.at(-1)) return\n\n        if (element.getAttribute('data-sanity-drag-disable')) return\n\n        // disable dnd in non-studio contexts\n        if (!inFrame || !optimisticActorReady) return\n\n        const targetSanityData = elementsMap.get(element)?.sanity\n\n        if (\n          !targetSanityData ||\n          !isSanityNode(targetSanityData) ||\n          !isSanityArrayPath(targetSanityData.path)\n        )\n          return\n\n        const dragGroup = resolveDragAndDropGroup(element, sanity, elementSet, elementsMap)\n\n        if (!dragGroup) return\n\n        handleOverlayDrag({\n          element,\n          handler,\n          mouseEvent: event as MouseEvent,\n          overlayGroup: dragGroup,\n          target: targetSanityData,\n          onSequenceStart: () => {\n            activeDragSequence = true\n          },\n          onSequenceEnd: () => {\n            // delay drag sequence end to prevent click events from firing just after drag sequences\n            setTimeout(() => {\n              activeDragSequence = false\n            }, 250)\n          },\n        })\n      },\n      mousemove(event) {\n        eventHandlers.mouseenter(event)\n        const el = event.currentTarget as ElementNode | null\n        if (el) {\n          el.addEventListener('mouseenter', eventHandlers.mouseenter as EventListener)\n          el.addEventListener('mouseleave', eventHandlers.mouseleave as EventListener)\n        }\n      },\n      mouseenter() {\n        // If the Vercel Visual Editing provided by Vercel Toolbar is active, do not overlap overlays\n        if (\n          (document.querySelector('vercel-live-feedback') &&\n            element.closest('[data-vercel-edit-info]')) ||\n          element.closest('[data-vercel-edit-target]')\n        ) {\n          return\n        }\n        hoverStack.push(element)\n\n        handler({\n          type: 'element/mouseenter',\n          id,\n          rect: getRect(element),\n        })\n\n        setOverlayCursor(element)\n      },\n      mouseleave(e) {\n        function leave() {\n          hoverStack.pop()\n          const hoveredElement = getHoveredElement()\n\n          handler({\n            type: 'element/mouseleave',\n            id,\n          })\n\n          if (hoveredElement) {\n            setOverlayCursor(hoveredElement)\n            const overlayElement = elementsMap.get(hoveredElement)\n            if (overlayElement) {\n              handler({\n                type: 'element/mouseenter',\n                id: overlayElement.id,\n                rect: getRect(hoveredElement),\n              })\n            }\n          }\n\n          restoreOverlayCursor(element)\n        }\n\n        /**\n         * If moving to an element within the overlay which handles pointer events, attach a new\n         * event handler to that element and defer the original leave event\n         */\n        function addDeferredLeave(el: ElementNode) {\n          const deferredLeave = (e: MouseEvent) => {\n            const {relatedTarget} = e\n            const deferredContainer = findOverlayElement(relatedTarget)\n            if (!deferredContainer) {\n              el.removeEventListener('mouseleave', deferredLeave as EventListener)\n              leave()\n            } else if (relatedTarget && isElementNode(relatedTarget)) {\n              el.removeEventListener('mouseleave', deferredLeave as EventListener)\n              addDeferredLeave(relatedTarget)\n            }\n          }\n          el.addEventListener('mouseleave', deferredLeave as EventListener)\n        }\n\n        const {relatedTarget} = e as MouseEvent\n        const container = findOverlayElement(relatedTarget)\n        const isInteractiveOverlayElement = overlayElement.contains(container)\n\n        if (isElementNode(container) && isInteractiveOverlayElement) {\n          return addDeferredLeave(container)\n        }\n\n        leave()\n      },\n    }\n\n    const id = uuid()\n    const sanityNode = {\n      id,\n      elements,\n      sanity,\n      handlers: eventHandlers,\n    }\n    elementSet.add(element)\n    measureElements.set(measureElement, element)\n    elementIdMap.set(id, element)\n    elementsMap.set(element, sanityNode)\n\n    io?.observe(element)\n\n    handler({\n      type: 'element/register',\n      id,\n      element,\n      rect: getRect(element),\n      sanity,\n      dragDisabled: !!element.getAttribute('data-sanity-drag-disable'),\n    })\n\n    if (activated) {\n      activateElement(sanityNode)\n    }\n  }\n\n  function updateElement({elements, sanity}: ResolvedElement) {\n    const {element} = elements\n    const overlayElement = elementsMap.get(element)\n    if (overlayElement) {\n      elementsMap.set(element, {...overlayElement, sanity})\n      handler({\n        type: 'element/update',\n        id: overlayElement.id,\n        rect: getRect(element),\n        sanity: sanity,\n      })\n    }\n  }\n\n  function parseElements(node: ElementNode | {childNodes: ElementNode[]}) {\n    const sanityNodes = findSanityNodes(node)\n    for (const sanityNode of sanityNodes) {\n      const {element} = sanityNode.elements\n      if (elementsMap.has(element)) {\n        updateElement(sanityNode)\n      } else {\n        registerElement(sanityNode)\n      }\n    }\n  }\n\n  function unregisterElement(element: ElementNode) {\n    const overlayElement = elementsMap.get(element)\n    if (overlayElement) {\n      const {id, handlers} = overlayElement\n      removeEventHandlers(element, handlers)\n      ro.unobserve(element)\n      elementsMap.delete(element)\n      elementSet.delete(element)\n      elementIdMap.delete(id)\n      handler({\n        type: 'element/unregister',\n        id,\n      })\n    }\n  }\n\n  function handleMutation(mutations: MutationRecord[]) {\n    let mutationWasInScope = false\n    // For each DOM mutation, we find the relevant element node and register or\n    // update it. This function doesn't handle checking if the node actually\n    // contains any relevant Sanity data, it just detects new or changed DOM\n    // elements and hands them off to `parseElements` to and determine if we\n    // have Sanity nodes\n    for (const mutation of mutations) {\n      const {target, type} = mutation\n      // We need to target an element, so if the mutated node was just a text\n      // change, we look at that node's parent instead\n      const node: Node | null = type === 'characterData' ? target.parentElement : target\n      // We ignore any nodes related to the overlay container element\n      if (node === overlayElement || overlayElement.contains(node)) {\n        continue\n      }\n\n      mutationWasInScope = true\n      if (isElementNode(node)) {\n        parseElements({childNodes: [node]})\n      }\n    }\n\n    // If the mutation is \"in scope\" (i.e. happened outside of the overlay\n    // container) we need to check if it removed any of the elements we are\n    // currently tracking\n    if (mutationWasInScope) {\n      for (const element of elementSet) {\n        if (!element.isConnected) {\n          unregisterElement(element)\n        }\n      }\n    }\n  }\n\n  function updateRect(el: ElementNode) {\n    const overlayElement = elementsMap.get(el)\n    if (overlayElement) {\n      handler({\n        type: 'element/updateRect',\n        id: overlayElement.id,\n        rect: getRect(el),\n      })\n    }\n  }\n\n  function handleResize(entries: ResizeObserverEntry[]) {\n    for (const entry of entries) {\n      const target = entry.target\n\n      if (isElementNode(target)) {\n        const element = measureElements.get(target)\n        if (!element) return\n        updateRect(element)\n      }\n    }\n  }\n\n  function handleIntersection(entries: IntersectionObserverEntry[]) {\n    if (!activated) return\n    for (const entry of entries) {\n      const {target} = entry\n      const match = isElementNode(target) && elementsMap.get(target)\n      if (!match) continue\n      if (entry.isIntersecting) {\n        activateElement(match)\n      } else {\n        deactivateElement(match)\n      }\n    }\n  }\n\n  function handleBlur(event: MouseEvent) {\n    const element = findOverlayElement(event.target)\n\n    if (element) {\n      if (element.dataset['sanityOverlayElement'] === 'capture') {\n        event.preventDefault()\n        event.stopPropagation()\n      }\n      return\n    }\n\n    hoverStack = []\n    handler({\n      type: 'overlay/blur',\n    })\n  }\n\n  function handleWindowResize() {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  }\n\n  function handleKeydown(event: KeyboardEvent) {\n    if (event.key === 'Escape') {\n      hoverStack = []\n      handler({\n        type: 'overlay/blur',\n      })\n    }\n  }\n\n  function handleWindowScroll(event: Event) {\n    const {target} = event\n\n    if (target === window.document || !isElementNode(target)) {\n      return\n    }\n\n    for (const element of elementSet) {\n      if (target.contains(element)) {\n        updateRect(element)\n      }\n    }\n  }\n\n  function activate() {\n    if (activated) return\n    io = new IntersectionObserver(handleIntersection, {\n      threshold: 0.3,\n    })\n    elementSet.forEach((element) => io!.observe(element))\n    handler({\n      type: 'overlay/activate',\n    })\n    activated = true\n  }\n\n  function deactivate() {\n    if (!activated) return\n    io?.disconnect()\n    elementSet.forEach((element) => {\n      const overlayElement = elementsMap.get(element)\n      if (overlayElement) {\n        deactivateElement(overlayElement)\n      }\n    })\n    handler({\n      type: 'overlay/deactivate',\n    })\n    activated = false\n  }\n\n  function destroy() {\n    window.removeEventListener('click', handleBlur)\n    window.removeEventListener('contextmenu', handleBlur)\n    window.removeEventListener('keydown', handleKeydown)\n    window.removeEventListener('resize', handleWindowResize)\n    window.removeEventListener('scroll', handleWindowScroll)\n    mo.disconnect()\n    ro.disconnect()\n\n    elementSet.forEach((element) => {\n      unregisterElement(element)\n    })\n\n    elementIdMap.clear()\n    elementSet.clear()\n\n    hoverStack = []\n    deactivate()\n  }\n\n  function create() {\n    window.addEventListener('click', handleBlur)\n    window.addEventListener('contextmenu', handleBlur)\n    window.addEventListener('keydown', handleKeydown)\n    window.addEventListener('resize', handleWindowResize)\n    window.addEventListener('scroll', handleWindowScroll, {\n      capture: true,\n      passive: true,\n    })\n    ro = new ResizeObserver(handleResize)\n    mo = new MutationObserver(handleMutation)\n    mo.observe(document.body, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n\n    parseElements(document.body)\n    activate()\n  }\n\n  window.document.fonts.ready.then(() => {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  })\n\n  create()\n\n  return {\n    activate,\n    deactivate,\n    destroy,\n  }\n}\n"],"names":["useOptimistic","byteToHex","i","push","toString","slice","getRandomValues","rnds8","Uint8Array","rng","crypto","Error","bind","native","randomUUID","v4","options","buf","offset","rnds","random","arr","toLowerCase","unsafeStringify","getRect","element","domRect","getBoundingClientRect","x","scrollX","y","scrollY","w","width","h","height","offsetRect","rect","px","axis","rayIntersect","l1","l2","x1","y1","x2","y2","x3","y3","x4","y4","denominator","ua","ub","rectEqual","r1","r2","rayRectIntersections","line","rectLines","intersections","length","intersection","isDuplicate","j","sort","a","b","pointDist","p1","p2","Math","sqrt","findClosestIntersection","ray","targets","flow","rayOrigin","some","pointInBounds","point","bounds","withinX","withinY","t","min","closestIntersection","closestRect","target","firstIntersection","scaleRect","scale","origin","originX","originY","getRectGroupYExtent","rects","minGroupY","max","map","r","maxGroupY","document","body","scrollHeight","findRectSanityData","overlayGroup","find","e","elements","sanity","resolveInsertPosition","insertPosition","Object","values","every","v","left","right","top","bottom","calcMousePos","bodyBounds","clientX","clientY","window","buildPreviewSkeleton","mousePos","scaleFactor","children","querySelectorAll","childRects","child","tagName","offsetX","offsetY","maxWidth","calcGroupBoundsPreview","groupBoundsX","minGroupX","maxGroupX","offsetWidth","getRectGroupXExtent","groupBoundsY","canOffsetX","innerWidth","canOffsetY","canOffset","offsetDist","async","resetMinimapWrapperTransform","endYOrigin","prescaleHeight","handler","rectUpdateFrequency","previousRootStyleValues","Promise","resolve","transform","getComputedStyle","DOMMatrix","maxScroll","innerHeight","prevScrollY","addEventListener","style","transition","scrollTo","behavior","setTimeout","type","display","once","overflow","documentElement","minimapScaleApplied","mousePosInverseTransform","handleOverlayDrag","opts","mouseEvent","onSequenceStart","onSequenceEnd","button","focus","getAttribute","filter","t2","t1","dragGroup","disableMinimap","preventInsertDefault","documentHeightOverride","groupHeightOverride","initialMousePos","scaleTarget","minYScaled","groupHeight","padding","scaledRects","calcMinimapTransformValues","sequenceStarted","minimapPromptShown","mousedown","rectsInterval","setInterval","applyMinimap","skeleton","transformOrigin","applyMinimapWrapperTransform","then","groupRect","handleScroll","abs","deltaY","shiftKey","dispatchEvent","CustomEvent","handleMouseMove","preventDefault","inverseMatrix","inverse","transformedPoint","DOMPoint","matrixTransform","calcMousePosInverseTransform","newInsertPosition","rayLeft","rayRight","rayTop","rayBottom","calcInsertPosition","stringify","JSON","handleMouseUp","clearInterval","removeFrameListeners","removeKeyListeners","removeMouseListeners","handleKeyup","key","handleBlur","removeEventListener","isElementNode","HTMLElement","SVGElement","findNonInlineElement","parent","parentElement","findOverlayElement","el","dataset","sanityOverlayElement","testAndDecodeStega","str","isAltText","input","VERCEL_STEGA_REGEX","lastIndex","test","decoded","vercelStegaDecode","href","replace","err","console","error","decodeStega","node","nodeType","Node","ELEMENT_NODE","isImgElement","isTimeElement","isSvgRootElement","toUpperCase","isSanityNode","findCommonPath","first","second","firstParts","split","secondParts","maxLength","reverse","reduce","parts","part","join","findCommonSanityData","nodes","n","_i","sanityNodes","common","consistentValueKeys","undefined","path","findSanityNodes","addElement","data","decodeSanityNodeData","measureElement","childNodes","textContent","sanityEditTarget","nodesInTarget","commonData","TEXT_NODE","sanityEditInfo","alt","dateTime","ariaLabel","isSanityArrayPath","lastDotIndex","lastIndexOf","substring","includes","getSanityNodeArrayPath","sanityNodesExistInSameArray","sanityNode1","sanityNode2","resolveDragAndDropGroup","elementSet","elementsMap","targetDragGroup","group","acc","elData","get","elDragDisabled","elDragGroup","elHasSanityAttribution","sharedDragGroup","SharedStateContext","createContext","exports","S","c","overlayElement","inFrame","optimisticActorReady","activated","elementIdMap","Map","WeakMap","Set","measureElements","cursorMap","ro","io","mo","activeDragSequence","hoverStack","getHoveredElement","removeEventHandlers","handlers","click","capture","contextmenu","mousemove","mouseenter","mouseleave","activateElement","id","addEventHandlers","observe","deactivateElement","unobserve","setOverlayCursor","hoverstackElement","targetSanityData","existingCursor","cursor","set","restoreOverlayCursor","previousCursor","registerElement","eventHandlers","event","contains","stopPropagation","sanity2","pop","position","currentTarget","at","querySelector","closest","leave","hoveredElement","relatedTarget","container","isInteractiveOverlayElement","addDeferredLeave","deferredLeave","uuid","sanityNode","add","dragDisabled","updateElement","parseElements","has","unregisterElement","delete","handleMutation","mutations","mutationWasInScope","mutation","isConnected","updateRect","handleResize","entries","entry","handleIntersection","match","isIntersecting","handleWindowResize","handleKeydown","handleWindowScroll","activate","IntersectionObserver","threshold","forEach","deactivate","disconnect","fonts","ready","passive","ResizeObserver","MutationObserver","attributes","characterData","childList","subtree","destroy","clear","s","u","passthrough","reducer","$","_c","pristine","setPristine","useState","optimistic","setOptimistic","lastEvent","setLastEvent","lastPassthrough","setLastPassthrough","actor","useOptimisticActor","t0","action","prevState","Array","isArray","reducer_0","getPublishedId","originalId","reduceStateFromAction","useEffectEvent","updateLastPassthrough","t3","t4","t5","isEmptyActor","pristineTimeout","rebasedSub","on","_event","clearTimeout","pristineSub","unsubscribe","useEffect","startTransition"],"mappings":"aAQOA,IAAAA,EAAAA,QAAAA,0BAAAA,EAAAA,QAAAA,SAAAA,EAAAA,QAAAA,oBAAAA,EAAAA,QAAAA,iBAAAA,EAAAA,QAAAA,mBAAAA,EAAAA,QAAAA,iCAAAA,EAAAA,QAAAA,iBCPP,MAAMC,EAAY,GAClB,IAAA,IAASC,EAAI,EAAGA,EAAI,MAAOA,EACbC,EAAAA,MAAMD,EAAI,KAAOE,SAAS,IAAIC,MAAM,ICHlD,IAAIC,EACJ,MAAMC,EAAQ,IAAIC,WAAW,IACd,SAASC,IACpB,IAAKH,EAAiB,CAClB,UAAWI,OAAW,MAAgBA,OAAOJ,gBACnC,MAAA,IAAIK,MAAM,4GAEFD,EAAAA,OAAOJ,gBAAgBM,KAAKF,OAClD,CACA,OAAOJ,EAAgBC,EAC3B,CCTA,IAAeM,EAAA,CAAEC,kBADSJ,OAAW,KAAeA,OAAOI,YAAcJ,OAAOI,WAAWF,KAAKF,SCGhG,SAASK,EAAGC,EAASC,EAAKC,GACtB,GAAIL,EAAOC,aAAeG,IAAQD,EAC9B,OAAOH,EAAOC,aAGlB,MAAMK,GADNH,EAAUA,GAAW,CAAE,GACFI,SAAWJ,EAAQP,KAAOA,KAC/CU,OAAAA,EAAK,GAAgB,GAAVA,EAAK,GAAa,GAC7BA,EAAK,GAAgB,GAAVA,EAAK,GAAa,IHL1B,SAAyBE,EAAKH,EAAS,GAClCjB,OAAAA,EAAUoB,EAAIH,EAAS,IAC3BjB,EAAUoB,EAAIH,EAAS,IACvBjB,EAAUoB,EAAIH,EAAS,IACvBjB,EAAUoB,EAAIH,EAAS,IACvB,IACAjB,EAAUoB,EAAIH,EAAS,IACvBjB,EAAUoB,EAAIH,EAAS,IACvB,IACAjB,EAAUoB,EAAIH,EAAS,IACvBjB,EAAUoB,EAAIH,EAAS,IACvB,IACAjB,EAAUoB,EAAIH,EAAS,IACvBjB,EAAUoB,EAAIH,EAAS,IACvB,IACAjB,EAAUoB,EAAIH,EAAS,KACvBjB,EAAUoB,EAAIH,EAAS,KACvBjB,EAAUoB,EAAIH,EAAS,KACvBjB,EAAUoB,EAAIH,EAAS,KACvBjB,EAAUoB,EAAIH,EAAS,KACvBjB,EAAUoB,EAAIH,EAAS,MAAMI,aACrC,CGRWC,CAAgBJ,EAC3B,CCjBO,SAASK,EAAQC,GAChBC,MAAAA,EAAUD,EAAQE,wBAEX,MAAA,CACXC,EAAGF,EAAQE,EAAIC,QACfC,EAAGJ,EAAQI,EAAIC,QACfC,EAAGN,EAAQO,MACXC,EAAGR,EAAQS,OAIf,CAEgBC,SAAAA,EAAWC,EAAmBC,EAAYC,GACxD,MAAa,MAATA,EACK,CACLX,EAAGS,EAAKT,EAAIU,EACZR,EAAGO,EAAKP,EACRE,EAAGK,EAAKL,EAAI,EAAIM,EAChBJ,EAAGG,EAAKH,GAGH,CACLN,EAAGS,EAAKT,EACRE,EAAGO,EAAKP,EAAIQ,EACZN,EAAGK,EAAKL,EACRE,EAAGG,EAAKH,EAAI,EAAII,EAGtB,CAGgBE,SAAAA,EAAaC,EAAWC,GAChC,MAAAC,GAACA,EAAAA,GAAIC,EAAAA,GAAIC,EAAAA,GAAIC,GAAML,GAClBE,GAAII,EAAIH,GAAII,EAAIH,GAAII,EAAIH,GAAII,GAAMR,EAGzC,GAAKC,IAAOE,GAAMD,IAAOE,GAAQC,IAAOE,GAAMD,IAAOE,EAC5C,OAAA,EAGT,MAAMC,GAAeD,EAAKF,IAAOH,EAAKF,IAAOM,EAAKF,IAAOD,EAAKF,GAG9D,GAAoB,IAAhBO,EACK,OAAA,EAGT,MAAMC,IAAOH,EAAKF,IAAOH,EAAKI,IAAOE,EAAKF,IAAOL,EAAKI,IAAOI,EACvDE,IAAOR,EAAKF,IAAOC,EAAKI,IAAOF,EAAKF,IAAOD,EAAKI,IAAOI,EAG7D,GAAIC,EAAK,GAAKA,EAAK,GAAKC,EAAK,GAAKA,EAAK,EAC9B,OAAA,EAMF,MAAA,CAACzB,EAHEe,EAAKS,GAAMP,EAAKF,GAGfb,EAFDc,EAAKQ,GAAMN,EAAKF,GAG5B,CAEgBU,SAAAA,EAAUC,EAAiBC,GACzC,OAAOD,EAAG3B,IAAM4B,EAAG5B,GAAK2B,EAAGzB,IAAM0B,EAAG1B,GAAKyB,EAAGvB,IAAMwB,EAAGxB,GAAKuB,EAAGrB,IAAMsB,EAAGtB,CACxE,CAEgBuB,SAAAA,EAAqBC,EAAarB,GAChD,MAAMsB,EAA0B,CAC9B,CAAChB,GAAIN,EAAKT,EAAGgB,GAAIP,EAAKP,EAAGe,GAAIR,EAAKT,EAAIS,EAAKL,EAAGc,GAAIT,EAAKP,GACvD,CACEa,GAAIN,EAAKT,EAAIS,EAAKL,EAClBY,GAAIP,EAAKP,EACTe,GAAIR,EAAKT,EAAIS,EAAKL,EAClBc,GAAIT,EAAKP,EAAIO,EAAKH,GAEpB,CACES,GAAIN,EAAKT,EAAIS,EAAKL,EAClBY,GAAIP,EAAKP,EAAIO,EAAKH,EAClBW,GAAIR,EAAKT,EACTkB,GAAIT,EAAKP,EAAIO,EAAKH,GAEpB,CACES,GAAIN,EAAKT,EACTgB,GAAIP,EAAKP,EAAIO,EAAKH,EAClBW,GAAIR,EAAKT,EACTkB,GAAIT,EAAKP,IAIP8B,EAAgC,GAEtC,IAAA,IAAS1D,EAAI,EAAGA,EAAIyD,EAAUE,OAAQ3D,IAAK,CACzC,MAAM4D,EAAetB,EAAakB,EAAMC,EAAUzD,IAElD,GAAI4D,EAAc,CAChB,IAAIC,GAAc,EAElB,IAAA,IAASC,EAAI,EAAGA,EAAIJ,EAAcC,OAAQG,IACtBA,EAAAA,GAAGpC,IAAMkC,EAAalC,GAAKgC,EAAcI,GAAGlC,IAAMgC,EAAahC,IAC/EiC,GAAc,GAIAH,GAAAA,EAAczD,KAAK2D,EAAY,CACnD,CAGEF,OAAyB,IAAzBA,EAAcC,QAIXD,EAAcK,MACnB,CAACC,EAAGC,IAAMC,EAAUF,EAAG,CAACtC,EAAG8B,EAAKf,GAAIb,EAAG4B,EAAKd,KAAOwB,EAAUD,EAAG,CAACvC,EAAG8B,EAAKf,GAAIb,EAAG4B,EAAKd,MAEzF,CACgBwB,SAAAA,EAAUC,EAAaC,GAC/BJ,MAAAA,EAAIG,EAAGzC,EAAI0C,EAAG1C,EACduC,EAAIE,EAAGvC,EAAIwC,EAAGxC,EAEpB,OAAOyC,KAAKC,KAAKN,EAAIA,EAAIC,EAAIA,EAC/B,CASgBM,SAAAA,EACdC,EACAC,EACAC,GAEA,MAAMC,EAAY,CAChBjD,EAAG8C,EAAI/B,GACPb,EAAG4C,EAAI9B,IAKP+B,GAAAA,EAAQG,MACNC,GApBUA,SAAcC,EAAgBC,GACtCC,MAAAA,EAAUF,EAAMpD,GAAKqD,EAAOrD,GAAKoD,EAAMpD,GAAKqD,EAAOrD,EAAIqD,EAAOjD,EAC9DmD,EAAUH,EAAMlD,GAAKmD,EAAOnD,GAAKkD,EAAMlD,GAAKmD,EAAOnD,EAAImD,EAAO/C,EAEpE,OAAOgD,GAAWC,CACpB,CAeMJ,CACEF,EACAzC,EAAWgD,EAAGb,KAAKc,IAAID,EAAEpD,EAAGoD,EAAElD,GAAK,GAAa,eAAT0C,EAAwB,IAAM,QAIlE,OAAA,KACT,IAAIU,EACAC,EAEJ,IAAA,MAAWC,KAAUb,EAAS,CAC5B,MAAMf,EAAgBH,EACpBiB,EACAtC,EAAWoD,EAAQjB,KAAKc,IAAIG,EAAOxD,EAAGwD,EAAOtD,GAAK,GAAa,eAAT0C,EAAwB,IAAM,MAEtF,GAAIhB,EAAe,CACX6B,MAAAA,EAAoB7B,EAAc,GAEpC0B,EACElB,EAAUS,EAAWY,GAAqBrB,EAAUS,EAAWS,KACjEA,EAAsBG,EACtBF,EAAcC,IAGhBF,EAAsBG,EACtBF,EAAcC,EAAAA,CAElB,CAGF,OAAID,GAEG,IACT,CAEgBG,SAAAA,EACdrD,EACAsD,EACAC,GAEM,MAAAhE,EAACA,EAAAA,EAAGE,EAAAA,EAAGE,EAAAA,EAAGE,GAAKG,GACdT,EAAGiE,EAAS/D,EAAGgE,GAAWF,EAQ1B,MAAA,CACLhE,EAPWiE,GAAWjE,EAAIiE,GAAWF,EAQrC7D,EAPWgE,GAAWhE,EAAIgE,GAAWH,EAQrC3D,EANeA,EAAI2D,EAOnBzD,EANgBA,EAAIyD,EAQxB,CAiBO,SAASI,EAAoBC,GAKlC,MAAMC,EAAY1B,KAAK2B,IAAI,EAAG3B,KAAKc,OAAOW,EAAMG,KAAWC,GAAAA,EAAEtE,MACvDuE,EAAY9B,KAAKc,IAAIiB,SAASC,KAAKC,aAAcjC,KAAK2B,OAAOF,EAAMG,KAAKC,GAAMA,EAAEtE,EAAIsE,EAAElE,MAErF,MAAA,CACLmD,IAAKY,EACLC,IAAKG,EACLlE,OAAQkE,EAAYJ,EAExB,CCvJA,SAASQ,EAAmBpE,EAAmBqE,GACtCA,OAAAA,EAAaC,MAAMC,GAAMtD,EAAU9B,EAAQoF,EAAEC,SAASpF,SAAUY,MACnEyE,MACN,CAEA,SAASC,EACPL,EACAM,EACApC,GAEIqC,OAAAA,OAAOC,OAAOF,GAAgBG,OAAaC,GAAM,OAANA,IAAoB,KAEtD,eAATxC,EACK,CACLyC,KAAML,EAAeK,KACjB,CACEhF,KAAM2E,EAAeK,KACrBP,OAAQL,EAAmBO,EAAeK,KAAMX,IAElD,KACJY,MAAON,EAAeM,MAClB,CACEjF,KAAM2E,EAAeM,MACrBR,OAAQL,EAAmBO,EAAeM,MAAOZ,IAEnD,MAGC,CACLa,IAAKP,EAAeO,IAChB,CACElF,KAAM2E,EAAeO,IACrBT,OAAQL,EAAmBO,EAAeO,IAAKb,IAEjD,KACJc,OAAQR,EAAeQ,OACnB,CACEnF,KAAM2E,EAAeQ,OACrBV,OAAQL,EAAmBO,EAAeQ,OAAQd,IAEpD,KAGV,CAEA,SAASe,EAAab,GACdc,MAAAA,EAAapB,SAASC,KAAK5E,wBAE1B,MAAA,CACLC,EAAG2C,KAAK2B,IAAIwB,EAAW9F,EAAG2C,KAAKc,IAAIuB,EAAEe,QAASD,EAAW9F,EAAI8F,EAAWzF,QACxEH,EAAG8E,EAAEgB,QAAUC,OAAO9F,QAE1B,CA0BA,SAAS+F,EAAqBC,EAAmBtG,EAAsBuG,GAC/D/C,MAAAA,EAASzD,EAAQC,GAEjBwG,EAAW,IACZxG,EAAQyG,iBAAiB,iEAG1BH,EAASnG,GAAKqD,EAAOrD,IAAGmG,EAASnG,EAAIqD,EAAOrD,GAC5CmG,EAASnG,GAAKqD,EAAOrD,EAAIqD,EAAOjD,IAAG+F,EAASnG,EAAIqD,EAAOrD,EAAIqD,EAAOjD,GAElE+F,EAASjG,GAAKmD,EAAOnD,EAAImD,EAAO/C,IAAG6F,EAASjG,EAAImD,EAAOnD,EAAImD,EAAO/C,GAClE6F,EAASjG,GAAKmD,EAAOnD,IAAGiG,EAASjG,EAAImD,EAAOnD,GAE1CqG,MAAAA,EAAaF,EAAS9B,KAAwBiC,IAElD,MAAM/F,EAAOqD,EAAUlE,EAAQ4G,GAAQJ,EAAa,CAClDpG,EAAGqD,EAAOrD,EACVE,EAAGmD,EAAOnD,IAGL,MAAA,CACLF,EAAGS,EAAKT,EAAIqD,EAAOrD,EACnBE,EAAGO,EAAKP,EAAImD,EAAOnD,EACnBE,EAAGK,EAAKL,EACRE,EAAGG,EAAKH,EACRmG,QAASD,EAAMC,QACjB,IAGK,MAAA,CACLC,SAAUrD,EAAOrD,EAAImG,EAASnG,GAAKoG,EACnCO,SAAUtD,EAAOnD,EAAIiG,EAASjG,GAAKkG,EACnChG,EAAGiD,EAAOjD,EAAIgG,EACd9F,EAAG+C,EAAO/C,EAAI8F,EACdQ,SAAUvD,EAAOjD,EAAIgG,EAAc,IACnCG,aAEJ,CAkEA,SAASM,EAAuBzC,GAC9B,MAAM0C,ED3DD,SAA6B1C,GAKlC,MAAM2C,EAAYpE,KAAK2B,IAAI,EAAG3B,KAAKc,OAAOW,EAAMG,KAAWC,GAAAA,EAAExE,MACvDgH,EAAYrE,KAAKc,IAAIiB,SAASC,KAAKsC,YAAatE,KAAK2B,OAAOF,EAAMG,KAAKC,GAAMA,EAAExE,EAAIwE,EAAEpE,MAEpF,MAAA,CACLqD,IAAKsD,EACLzC,IAAK0C,EACL3G,MAAO2G,EAAYD,EAEvB,CC8CuBG,CAAoB9C,GACnC+C,EAAehD,EAAoBC,GAInCgD,EACJN,EAAarD,IAHI,GAIjBqD,EAAarD,IAAMqD,EAAazG,OAAS4F,OAAOoB,WAJ/B,EAKbC,EACJH,EAAa1D,IANI,GAOjB0D,EAAa1D,IAAM0D,EAAa5G,QAAUmE,SAASC,KAAKC,aAPvC,EAQb2C,EAAYH,GAAcE,EAEd,MAAA,CAChBtH,EAAGuH,EAAYT,EAAarD,IAXX,EAW8BqD,EAAarD,IAC5DvD,EAAGqH,EAAYJ,EAAa1D,IAZX,EAY8B0D,EAAa1D,IAC5DrD,EAAGmH,EAAYT,EAAazG,MAAQmH,GAAiBV,EAAazG,MAClEC,EAAGiH,EAAYJ,EAAa5G,OAASiH,GAAiBL,EAAa5G,OAIvE,CAEAkH,eAAeC,EACbC,EACA/D,EACAgE,EACAC,EACAC,EACAC,GAEO,OAAA,IAAIC,SAAqBC,IAE9B,MAAMC,EADgBjC,OAAOkC,iBAAiBvE,GACdsE,UAMhC,GAAc,IAJC,IAAIE,UAAUF,GAER5F,EAEJ,OAEjB,MAAM+F,EAAYT,EAAiB3B,OAAOqC,YACpCC,EAAcpI,SAEN8F,GAAAA,OAAOqC,YAAc,GAElB,IAAGX,EAAa,GAEjC/D,EAAO4E,iBACL,iBACA,KACE5E,EAAO6E,MAAMC,WAAa,OAC1B9E,EAAO6E,MAAMP,UAAY,OAEzBS,SAAS,CACPhD,IAAKgC,EACLiB,SAAU,YAGZC,YAAW,KACDhB,EAAA,CACNiB,KAAM,qCAGRjB,EAAQ,CACNiB,KAAM,4BACNC,SAAS,GACV,GACsB,EAAtBjB,GAEHG,GAAQ,GAEV,CAACe,MAAM,IAGTnB,EAAQ,CACNiB,KAAM,uCAGRlF,EAAO6E,MAAMP,UAAY,cAAcvF,KAAK2B,IAAIiE,EAAcZ,GAAaU,EAAYE,iBAElFR,IAELrD,SAASC,KAAK8D,MAAMQ,SAAWlB,EAAwBpD,KAAKsE,SAC5DvE,SAASC,KAAK8D,MAAMlI,OAASwH,EAAwBpD,KAAKpE,OAC1DmE,SAASwE,gBAAgBT,MAAMQ,SAAWlB,EAAwBmB,gBAAgBD,SAClFvE,SAASwE,gBAAgBT,MAAMlI,OAASwH,EAAwBmB,gBAAgB3I,OAAAA,GAEpF,CAuBA,IAAI4I,GAAsB,EAEtBC,EAA2B,CAACpJ,EAAG,EAAGE,EAAG,GACrCiG,EAAW,CAACnG,EAAG,EAAGE,EAAG,GAErB0H,SAAwBlD,SAAa,IAAc,EAAIA,SAASwE,gBAAgBtE,aAEhFmD,EAA0D,KAEvD,SAASsB,EAAkBC,GAC1B,MAAAC,WAACA,EAAAA,QAAY1J,EAAAA,aAASiF,EAAAA,QAAc+C,EAAAA,OAASjE,EAAAA,gBAAQ4F,EAAAA,cAAiBC,GAAiBH,EAGzFC,GAAsB,IAAtBA,EAAWG,OAAc,OAG7BzD,OAAO0D,QAEP,MAAM7B,EAAsB,IACxB1D,IAAAA,EAAQU,EAAaP,KAAKS,GAAMpF,EAAQoF,EAAEC,SAASpF,WAEvD,MAAMmD,EAAQnD,EAAQ+J,aAAa,4BApXb7G,EAoXwDqB,GAlXpElB,MACSH,GAAAA,EAAQ8G,QAAeC,IAACpI,EAAUqI,EAAID,KAEvC5G,SACL6G,EAAG7J,IAAM4J,EAAG5J,MAIhB,aAEA,YA4WH8J,EAAYnK,EAAQ+J,aAAa,0BAEjCK,IAAmBpK,EAAQ+J,aAAa,oCAExCM,IAAyBrK,EAAQ+J,aAAa,oCAE9CO,EAAyBtK,EAAQ+J,aAAa,6CAC9CQ,EAAsBvK,EAAQ+J,aAAa,0CA/XnD,IAAwB7G,EAiYtB,IAAIqC,EAAiD,KAErD,MAAMiF,EAAkBxE,EAAa0D,GAE/Be,EAAc5F,SAASC,MAEvB4F,WAACA,EAAAA,YAAYnE,GAzKrB,SAAoChC,EAAsBgG,GACxD,IAAII,EAAcJ,GAAuBjG,EAAoBC,GAAO7D,OAIpEiK,GAAeC,IAEf,MAAMrE,EAAcoE,EAAcvE,OAAOqC,YAAcrC,OAAOqC,YAAckC,EAAc,EACpFE,EAActG,EAAMG,KAAWT,GAAAA,EAAUU,EAAG4B,EAAa,CAACpG,EAAGiG,OAAOoB,WAAa,EAAGnH,EAAG,OAEtFuD,IAAK8G,GAAcpG,EAAoBuG,GAEvC,MAAA,CACLtE,cACAmE,WAAYA,EAXE,IAWqBnE,EAEvC,CAyJoCuE,CAChCvG,EACAgG,IAAwBA,EAAsB,MAGhD,IAAIQ,GAAkB,EAClBC,GAAqB,EAErBC,GAAY,EAEX3B,IACHpB,EAA0B,CACxBpD,KAAM,CACJsE,SAAUhD,OAAOkC,iBAAiBzD,SAASC,MAAMsE,SACjD1I,OAAQ0F,OAAOkC,iBAAiBzD,SAASC,MAAMpE,QAEjD2I,gBAAiB,CACfD,SAAUhD,OAAOkC,iBAAiBzD,SAASwE,iBAAiBD,SAC5D1I,OAAQ0F,OAAOkC,iBAAiBzD,SAASwE,iBAAiB3I,SAI9DqH,EAAiBuC,IACXA,EACFzF,SAASwE,gBAAgBtE,cAGzBmG,MAAAA,EAAgBC,aAAY,KACxBlG,EAAAA,EAAaP,KAAKS,GAAMpF,EAAQoF,EAAEC,SAASpF,UAAQ,GAC1DiI,GAEGmD,EAAeA,KACnB,GAAI7E,GAAe,EAAG,OAEtB,MAAM8E,EAAWhF,EAAqBC,EAAUtG,EAASuG,GAEjDyB,EAAA,CACNiB,KAAM,6BACNoC,aAGFrD,EAAQ,CACNiB,KAAM,kCACNC,SAAS,IAGXlB,EAAQ,CACNiB,KAAM,4BACNC,SAAS,IAGXI,GAAsB,EAzQ1B1B,eACE7D,EACAwC,EACAmE,EACA1C,EACAC,GAEO,OAAA,IAAIE,SAAqBC,IACvBO,EAAAA,iBACL,iBACA,KACEK,YAAW,KACDhB,EAAA,CACNiB,KAAM,oCACP,GACsB,EAAtBhB,GAEHG,GAAQ,GAEV,CAACe,MAAM,IAGTnB,EAAQ,CACNiB,KAAM,uCAGRjB,EAAQ,CACNiB,KAAM,4BACNC,SAAS,IAGXrE,SAASC,KAAK8D,MAAMQ,SAAW,SAC/BvE,SAASC,KAAK8D,MAAMlI,OAAS,OAC7BmE,SAASwE,gBAAgBT,MAAMQ,SAAW,UAC1CvE,SAASwE,gBAAgBT,MAAMlI,OAAS,OAGxCsI,YAAW,KACTjF,EAAO6E,MAAM0C,gBAAkB,UAC/BvH,EAAO6E,MAAMC,WAAa,uBAC1B9E,EAAO6E,MAAMP,UAAY,qBAAqBqC,EAAapK,yBAAyBiG,IAAW,GAC9F,GAAE,GAET,CAgOIgF,CACEd,EACAlE,EACAmE,EACA1C,EACAC,GACAuD,MAAK,KACLxC,YAAW,KACDhB,EAAA,CACNiB,KAAM,8BACNwC,UAAWzE,EAAuBzC,IACnC,GACA0D,IAAuB,GAC3B,EAGGyD,EAAkCvG,IAEpCrC,KAAK6I,IAAIxG,EAAEyG,SAAW,IACtBrF,EAAc,IACb+C,IACA0B,IACAZ,GACDa,IAEAjD,EAAQ,CACNiB,KAAM,kCACNC,SAAS,IAGX8B,GAAqB,GAGnB7F,EAAE0G,WAAavC,IAAwBc,IACzChE,OAAO0F,cAAc,IAAIC,YAAY,qCAErC/C,YAAW,KACIoC,GAAA,GACZ,IAAE,EAIHY,EAA2C7G,IAM/C,GALAA,EAAE8G,iBAEF3F,EAAWN,EAAab,GACxBoE,EA1XJ,SAAsCjD,GACpC,MAAMxB,EAAOD,SAASC,KAEhBuD,EADgBjC,OAAOkC,iBAAiBxD,GACduD,UAEhC,GAAkB,SAAdA,EACK,MAAA,CACLlI,EAAGmG,EAASnG,EACZE,EAAGiG,EAASjG,GAKhB,MAAM6L,EADS,IAAI3D,UAAUF,GACA8D,UAGvBC,EADQ,IAAIC,SAAS/F,EAASnG,EAAGmG,EAASjG,GACjBiM,gBAAgBJ,GAExC,MAAA,CACL/L,EAAGiM,EAAiBjM,EACpBE,EAAG+L,EAAiB/L,EAExB,CAoW+BkM,CAA6BjG,GAEpDxD,KAAK6I,IAAIhJ,EAAU2D,EAAUkE,IA7ThB,EA6TkD,OAEnE,IAAKO,EAAiB,CACdU,MAAAA,EAAYzE,EAAuBzC,GAEnC8G,EAAWhF,EAAqBC,EAAUtG,EAAS,GAEjDgI,EAAA,CACNiB,KAAM,oBACN9F,SAGF6E,EAAQ,CACNiB,KAAM,6BACNoC,aAGFrD,EAAQ,CACNiB,KAAM,8BACNwC,cAGFV,GAAkB,EAClBpB,GAAgB,CAGV3B,EAAA,CACNiB,KAAM,mCACN9I,EAAGmG,EAASnG,EACZE,EAAGiG,EAASjG,IAGV8E,EAAE0G,WAAavC,IAAwBc,IACzChE,OAAO0F,cAAc,IAAIC,YAAY,qCAErC/C,YAAW,KACIoC,GAAA,GACZ,KAGL,MAAMoB,EApgBV,SAA4BrI,EAAiBjB,EAAwBC,GACnE,GAAa,eAATA,EAAuB,CACzB,MAAMsJ,EAAU,CACdvL,GAAIiD,EAAOhE,EACXgB,GAAIgD,EAAO9D,EACXe,GAAI+C,EAAOhE,EAAI,IACfkB,GAAI8C,EAAO9D,GAGPqM,EAAW,CACfxL,GAAIiD,EAAOhE,EACXgB,GAAIgD,EAAO9D,EACXe,GAAI+C,EAAOhE,EAAI,IACfkB,GAAI8C,EAAO9D,GAGN,MAAA,CACLuF,KAAM5C,EAAwByJ,EAASvJ,EAASC,GAChD0C,MAAO7C,EAAwB0J,EAAUxJ,EAASC,GACpD,CACK,CACL,MAAMwJ,EAAS,CACbzL,GAAIiD,EAAOhE,EACXgB,GAAIgD,EAAO9D,EACXe,GAAI+C,EAAOhE,EACXkB,GAAI8C,EAAO9D,EAAI,KAGXuM,EAAY,CAChB1L,GAAIiD,EAAOhE,EACXgB,GAAIgD,EAAO9D,EACXe,GAAI+C,EAAOhE,EACXkB,GAAI8C,EAAO9D,EAAI,KAGV,MAAA,CACLyF,IAAK9C,EAAwB2J,EAAQzJ,EAASC,GAC9C4C,OAAQ/C,EAAwB4J,EAAW1J,EAASC,GACtD,CAEJ,CA4d8B0J,CAAmBvG,EAAU/B,EAAOpB,GAErD2J,KAAAA,UAAUvH,KAAoBwH,KAAKD,UAAUN,KACpDjH,EAAiBiH,EAEjBxE,EAAQ,CACNiB,KAAM,mCACN1D,eAAgBD,EAAsBL,EAAcM,EAAgBpC,KACrE,EAIC6J,EAAgBA,KACpB/B,GAAY,EAEZjD,EAAQ,CACNiB,KAAM,kBACNlF,SACAwB,eAAgBA,EACZD,EAAsBL,EAAcM,EAAgBpC,GACpD,KACJgH,YACAhH,OACAkH,yBAGEW,GACFhD,EAAQ,CACNiB,KAAM,kCACNC,SAAS,IAIRI,IACH2D,cAAc/B,GACdtB,IAEAsD,IACAC,KAGFC,GAAqB,EAGjBC,EAAoClI,IACpCA,GAAU,UAAVA,EAAEmI,KAAmBhE,EAAqB,CACtBA,GAAA,EAEtB,MAAM+B,EAAWhF,EAAqBC,EAAUtG,EAAS,EAAIuG,GAErDyB,EAAA,CACNiB,KAAM,6BACNoC,aAGFjF,OAAO0F,cAAc,IAAIC,YAAY,qCAErC/C,YAAW,KACTnB,EACE0B,EAAyBlJ,EACzBoK,EACA1C,EACAC,EACAC,EACAC,EACF,GACC,IAEHF,EAAQ,CACNiB,KAAM,8BACNwC,UAAW,OAIRR,IACHgC,cAAc/B,GAEdkC,IACAF,IACAC,IAEAvD,IAAc,GAKd2D,EAAaA,KACTvF,EAAA,CACNiB,KAAM,8BACNwC,UAAW,OAGbrF,OAAO0F,cAAc,IAAIC,YAAY,qCAErC/C,YAAW,KAEPO,EAAAA,EAAyBlJ,EACzBoK,EACA1C,EACAC,EACAC,EACAC,GACAsD,MAAK,KACiBlC,GAAA,CAAA,GACvB,GACA,IAEH2D,cAAc/B,GAEdkC,IACAF,IACAC,IAEAvD,GAAc,EAGVwD,EAAuBA,KAC3BhH,OAAOoH,oBAAoB,YAAaxB,GACxC5F,OAAOoH,oBAAoB,QAAS9B,GACpCtF,OAAOoH,oBAAoB,UAAWR,EAAa,EAG/CG,EAAqBA,KAClBK,OAAAA,oBAAoB,QAASH,EAAW,EAG3CH,EAAuBA,KACpBM,OAAAA,oBAAoB,OAAQD,EAAU,EAGxC5E,OAAAA,iBAAiB,OAAQ4E,GAChCnH,OAAOuC,iBAAiB,QAAS0E,GACjCjH,OAAOuC,iBAAiB,QAAS+C,GACjCtF,OAAOuC,iBAAiB,YAAaqD,GACrC5F,OAAOuC,iBAAiB,UAAWqE,EACrC,CC7qBO,MAAMS,EAAiB1J,GACrBA,aAAkB2J,aAAe3J,aAAkB4J,WAGrD,SAASC,EAAqB5N,GAC7B,MAAAkJ,QAACA,GAAW9C,OAAOkC,iBAAiBtI,GAEtCkJ,GAAY,WAAZA,EAA6BlJ,OAAAA,EAEjC,MAAM6N,EAAS7N,EAAQ8N,cAElBD,OAAAA,EAEED,EAAqBC,GAFR,IAGtB,CAEO,MAAME,EACXC,GAEKA,GAAOP,EAAcO,GAItBA,EAAGC,SAAUC,qBACRF,EAGFD,EAAmBC,EAAGF,eAPpB,KCQKK,SAAAA,EAAmBC,EAAaC,GAAY,GAC1D,OAvB4BC,EAuBHF,EAtBzBG,EAAAA,mBAAmBC,UAAY,EACxBD,EAAAA,mBAAmBE,KAAKH,GAGjC,SAAqBF,EAAaC,GAAY,GACxC,IACIK,MAAAA,EAAUC,oBAAmCP,GACnD,OAAKM,GAA8B,cAAnBA,EAAQvK,QAGpBkK,IACFK,EAAQE,KAAOF,EAAQE,MAAMC,QAAQ,OAAQ,KAExCH,GALE,WAMFI,GAEPC,OAAAA,QAAQC,MAAM,sCAAuCZ,EAAK,4BAA6BU,GAChF,IAAA,CAEX,CAIWG,CAAYb,EAAKC,GAEnB,KA1BT,IAA8BC,CA2B9B,CCxBA,MAAMb,KAA0DyB,EAAKC,WAAaC,KAAKC,aAEjFC,KAA2E,QAAftB,EAAGpH,QAE/D2I,EAAiBvB,GAA0D,SAAfA,EAAGpH,QAE/D4I,EACJxB,GAA6B,QAA7BA,EAAGpH,QAAQ6I,cAEN,SAASC,EAAaR,GAC3B,MAAO,SAAUA,CACnB,CAQgBS,SAAAA,EAAeC,EAAeC,GACxCC,IAAAA,EAAaF,EAAMG,MAAM,KACzBC,EAAcH,EAAOE,MAAM,KAC/B,MAAME,EAAYnN,KAAKc,IAAIkM,EAAW1N,OAAQ4N,EAAY5N,QAC1D0N,OAAAA,EAAaA,EAAWlR,MAAM,EAAGqR,GAAWC,UAC5CF,EAAcA,EAAYpR,MAAM,EAAGqR,GAAWC,UAEvCJ,EACJK,QAAO,CAACC,EAAOC,EAAM5R,IAAO4R,IAASL,EAAYvR,GAAK,IAAI2R,EAAOC,GAAQ,IAAK,IAC9EH,UACAI,KAAK,IACV,CASO,SAASC,EACdC,GAGI,IAACA,EAAMpO,SAAWoO,EAAM9L,QAAWgL,EAAae,KAAI/K,OAAM,CAAC+K,EAAGC,EAAI9Q,IAAQ6Q,IAAM7Q,EAAI,KACtF,OAGE,IAAC8P,EAAac,EAAM,IAAK,OAAOA,EAAM,GAEpCG,MAAAA,EAAcH,EAAMxG,OAAO0F,GAC7BkB,IAAAA,EAAiCJ,EAAM,GAE3C,MAAMK,EAA+C,CACnD,YACA,UACA,KACA,UACA,YACA,QAEF,IAAA,IAASpS,EAAI,EAAGA,EAAIkS,EAAYvO,OAAQ3D,IAAK,CACrCyQ,MAAAA,EAAOyB,EAAYlS,GACrBoS,GAAAA,EAAoBxN,MAAc6L,GAAAA,EAAK5B,KAASsD,IAAStD,KAAO,CACzDwD,OAAAA,EACT,KAAA,CAGFF,EAAOG,KAAOpB,EAAeiB,EAAOG,KAAM7B,EAAK6B,KAAI,CAG9CH,OAAAA,CACT,CAQO,SAASI,EACdhD,GAEA,MAAM5I,EAA8B,GAE3B6L,SAAAA,EAAWjR,EAAsBkR,GAClC7L,MAAAA,EAAS8L,IAAqBD,GACpC,IAAK7L,EACH,OAII+L,MAAAA,EAAiBxD,EAAqB5N,GACvCoR,GAILhM,EAAS1G,KAAK,CACZ0G,SAAU,CACRpF,UACAoR,kBAEF/L,UACD,CAGC2I,GAAAA,EACSkB,IAAAA,MAAAA,KAAQlB,EAAGqD,WAAY,CAC1B,MAAAlC,SAACA,EAAAA,cAAUrB,EAAAA,YAAewD,GAAepC,EAE/C,GAAIzB,EAAcyB,SAAgD4B,IAAvC5B,EAAKjB,SAAUsD,iBAAmC,CAC3E,MAAMC,EAAgBR,EAAgB9B,GAAMxK,KAAI,EAAEW,YAAYA,IAE9D,IAAKmM,EAAc9M,KAAWgL,GAAAA,EAAae,KAAI/K,OAAM,CAAC+K,EAAGC,EAAI9Q,IAAQ6Q,IAAM7Q,EAAI,KAC7E,SAGI6R,MAAAA,EAAalB,EAAqBiB,GAEpCC,GACFrM,EAAS1G,KAAK,CACZ0G,SAAU,CACRpF,QAASkP,EACTkC,eAAgBlC,GAElB7J,OAAQoM,GAKHtC,MAAAA,GAAAA,IAAaC,KAAKsC,WAAa5D,GAAiBwD,EAAa,CAChEJ,MAAAA,EAAO/C,EAAmBmD,GAChC,IAAKJ,EAAM,SACXD,EAAWnD,EAAeoD,EAAI,MAAA,GAGvBzD,EAAcyB,GAAO,CAG5B,GAAqB,WAAjBA,EAAKtI,SAAyC,0BAAjBsI,EAAKtI,QACpC,SAIF,GAAIsI,EAAKjB,SAAU5I,OACN6J,EAAAA,EAAMA,EAAKjB,QAAQ5I,aAAS,GAGhC6J,EAAKjB,SAAU0D,eACXzC,EAAAA,EAAMA,EAAKjB,QAAQ0D,oBACrBrC,IAAAA,EAAaJ,GAAO,CAC7B,MAAMgC,EAAO/C,EAAmBe,EAAK0C,KAAK,GAC1C,IAAKV,EAAM,SACXD,EAAW/B,EAAMgC,GAEjB,QAAA,CAAA,GACS3B,EAAcL,GAAO,CAC9B,MAAMgC,EAAO/C,EAAmBe,EAAK2C,UAAU,GAC/C,IAAKX,EAAM,SACXD,EAAW/B,EAAMgC,EAAI,MAAA,GACZ1B,EAAiBN,GAAO,CAC7B,IAACA,EAAK4C,UAAW,SACrB,MAAMZ,EAAO/C,EAAmBe,EAAK4C,WAAW,GAChD,IAAKZ,EAAM,SACXD,EAAW/B,EAAMgC,EAAI,EAGvB9L,EAAS1G,QAAQsS,EAAgB9B,GAAK,CACxC,CAGG9J,OAAAA,CACT,CAEO,SAAS2M,EAAkBhB,GAC1BiB,MAAAA,EAAejB,EAAKkB,YAAY,KAGtC,OAFqBlB,EAAKmB,UAAUF,EAAcjB,EAAK3O,QAEnC+P,SAAS,IAC/B,CAEO,SAASC,EAAuBrB,GACrC,IAAKgB,EAAkBhB,GAAc,OAAA,KAE/BhB,MAAAA,EAAQgB,EAAKhB,MAAM,KAEzBA,OAAAA,EAAMA,EAAM3N,OAAS,GAAK2N,EAAMA,EAAM3N,OAAS,GAAGyM,QAAQ,WAAY,MAE/DkB,EAAMO,KAAK,IACpB,CAEgB+B,SAAAA,EACdC,EACAC,GAEA,SAAKR,EAAkBO,EAAYvB,QAAUgB,EAAkBQ,EAAYxB,QAEpEqB,EAAuBE,EAAYvB,QAAUqB,EAAuBG,EAAYxB,KACzF,CAEO,SAASyB,EACdxS,EACAqF,EACAoN,EACAC,GAEI,IAAC1S,EAAQ+J,aAAa,gBAEtB/J,EAAQ+J,aAAa,8BAEpB1E,IAAWqK,EAAarK,KAAY0M,EAAkB1M,EAAO0L,MAAc,OAAA,KAEhF,MAAM4B,EAAkB3S,EAAQ+J,aAAa,0BAEvC6I,EAAQ,IAAIH,GAAYtC,QAAyB,CAAC0C,EAAK7E,KACrD8E,MAAAA,EAASJ,EAAYK,IAAI/E,GACzBgF,EAAiBhF,EAAGjE,aAAa,4BACjCkJ,EAAcjF,EAAGjE,aAAa,0BAC9BmJ,EAA4D,OAAnClF,EAAGjE,aAAa,eAEzCoJ,EAAsC,OAApBR,GAA2BA,IAAoBM,EAEvE,OACEH,IACCE,GACDtD,EAAaoD,EAAOzN,SACpBgN,EAA4BhN,EAAQyN,EAAOzN,SAC3C8N,GACAD,GAEAL,EAAInU,KAAKoU,GAGJD,CAAAA,GACN,IAECD,OAAAA,EAAMxQ,QAAU,EAAU,KAEvBwQ,CACT,CChPaQ,MAAAA,EAAqBC,EAAAA,cAA8C,MAAIC,QAAAC,EAAAH,EAAAE,QAAAE,ECiB7E,UAAiCxL,QACtCA,EAAAA,eACAyL,EAAAA,QACAC,EAAAA,qBACAC,IAEA,IAAIC,GAAY,EAEVC,MAAAA,MAAmBC,IAEnBpB,EAAkBqB,IAAAA,QAElBtB,EAAa,IAAIuB,IAEjBC,MAAsBF,QAEtBG,EAAgBH,IAAAA,QAEhB9H,EAAiByH,EAEvB,IAAIS,EACAC,EACAC,EAEAC,GAAqB,EAYrBC,EAAiC,GACrC,MAAMC,EAAoBA,IAAMD,EAAWA,EAAWnS,OAAS,GAqBtDqS,SAAAA,EAAoBzG,EAAiB0G,GACzClH,EAAAA,oBAAoB,QAASkH,EAASC,MAAwB,CAC/DC,SAAS,IAEX5G,EAAGR,oBAAoB,cAAekH,EAASG,YAA8B,CAC3ED,SAAS,IAEX5G,EAAGR,oBAAoB,YAAakH,EAASI,UAA4B,CACvEF,SAAS,IAEX5G,EAAGR,oBAAoB,YAAakH,EAASzJ,UAA4B,CACvE2J,SAAS,IAEX5G,EAAGR,oBAAoB,aAAckH,EAASK,YAC9C/G,EAAGR,oBAAoB,aAAckH,EAASM,WAA2B,CAO3E,SAASC,GAAgBC,GAACA,EAAAA,SAAI9P,EAAAA,SAAUsP,IAChC,MAAA1U,QAACA,EAAAA,eAASoR,GAAkBhM,GAzC3B+P,SAAiBnH,EAAiB0G,GACtC/L,EAAAA,iBAAiB,QAAS+L,EAASC,MAAwB,CAC5DC,SAAS,IAEX5G,EAAGrF,iBAAiB,cAAe+L,EAASG,YAA8B,CACxED,SAAS,IAIX5G,EAAGrF,iBAAiB,YAAa+L,EAASI,UAA4B,CACpE3L,MAAM,EACNyL,SAAS,IAGX5G,EAAGrF,iBAAiB,YAAa+L,EAASzJ,UAA4B,CACpE2J,SAAS,GACV,EA0BDO,CAAiBnV,EAAS0U,GAC1BP,EAAGiB,QAAQhE,GACXpJ,EAAQ,CACNiB,KAAM,mBACNiM,MACD,CAOH,SAASG,GAAkBH,GAACA,EAAAA,SAAI9P,EAAAA,SAAUsP,IAClC,MAAA1U,QAACA,EAAAA,eAASoR,GAAkBhM,EAClCqP,EAAoBzU,EAAS0U,GAC7BP,EAAGmB,UAAUlE,GAEbmD,EAAaA,EAAWvK,QAAQgE,GAAOA,IAAOhO,IAC9CgI,EAAQ,CACNiB,KAAM,qBACNiM,MACD,CAGH,SAASK,EAAiBvV,GAEpB,GAAC0T,GAAYC,EAKjB,IAAA,MAAW6B,KAAqBjB,EAAY,CAC1C,GAAIvU,IAAYwV,EAAmB,CACjC,MAAMC,EAAmB/C,EAAYK,IAAI/S,IAAUqF,OACnD,IAAKoQ,IAAqB/F,EAAa+F,GAAmB,OAS1D,GAPkBjD,EAChBxS,EACAyV,EACAhD,EACAC,GAGa,CAEPgD,MAAAA,EAAiB1V,EAAQ4I,MAAM+M,OACjCD,GACFxB,EAAU0B,IAAI5V,EAAS0V,GAGzB1N,EAAQ,CACNiB,KAAM,oBACNjJ,UACA2V,OAAQ,SAGV,QAAA,CACF,CAGFE,EAAqBL,EAAiB,CACxC,CAGF,SAASK,EAAqB7V,GAEtB8V,MAAAA,EAAiB5B,EAAUnB,IAAI/S,GAE7BgI,EAAA,CACNiB,KAAM,oBACNjJ,UACA2V,OAAQG,GACT,CAMH,SAASC,GAAgB3Q,SAACA,EAAAA,OAAUC,IAC5B,MAAArF,QAACA,EAAAA,eAASoR,GAAkBhM,EAE5B4Q,EAA+B,CACnCrB,KAAAA,CAAMsB,GACJ,MAAMlS,EAASkS,EAAMlS,OAErB,GAAI/D,IAAYwU,KAAuBxU,EAAQkW,SAASnS,GAAS,CAC3DkI,IACFgK,EAAMhK,iBACNgK,EAAME,mBAGR,MAAM9Q,EAASqN,EAAYK,IAAI/S,IAAUqF,OAC3B+Q,IAAC9B,GACbtM,EAAQ,CACNiB,KAAM,gBACNiM,KACA7P,OAAAA,GACD,CAGP,EACAwP,WAAAA,CAAYoB,GAOV,KANM,SAAU5Q,GAAYqO,GAAYC,GAMnCtO,EAAO0L,KAAKhB,MAAM,KAAKsG,OAAOlE,SAAS,YAAY,OAExD,MAAMpO,EAASkS,EAAMlS,OACjB/D,IAAYwU,KAAuBxU,EAAQkW,SAASnS,KAClDkI,IACFgK,EAAMhK,iBACNgK,EAAME,mBAERnO,EAAQ,CACNiB,KAAM,sBACNiM,KACAoB,SAAU,CACRnW,EAAG8V,EAAM/P,QACT7F,EAAG4V,EAAM9P,SAEXd,WAGN,EACA4F,SAAAA,CAAUgL,GASR,GAPAA,EAAMhK,iBAEFgK,EAAMM,gBAAkBhC,EAAWiC,IAAG,IAEtCxW,EAAQ+J,aAAa,8BAGpB2J,IAAYC,EAAsB,OAEvC,MAAM8B,EAAmB/C,EAAYK,IAAI/S,IAAUqF,OAGjD,IAACoQ,IACA/F,EAAa+F,KACb1D,EAAkB0D,EAAiB1E,MAEpC,OAEF,MAAM5G,EAAYqI,EAAwBxS,EAASqF,EAAQoN,EAAYC,GAElEvI,GAELX,EAAkB,CAChBxJ,UACAgI,UACA0B,WAAYuM,EACZhR,aAAckF,EACdpG,OAAQ0R,EACR9L,gBAAiBA,KACM2K,GAAA,CAAA,EAEvB1K,cAAeA,KAEbZ,YAAW,KACYsL,GAAA,CAAA,GACpB,IAAG,GAGZ,EACAQ,SAAAA,CAAUmB,GACRD,EAAcjB,WAAWkB,GACzB,MAAMjI,EAAKiI,EAAMM,cAEfvI,IAAAA,EAAGrF,iBAAiB,aAAcqN,EAAcjB,YAChD/G,EAAGrF,iBAAiB,aAAcqN,EAAchB,YAEpD,EACAD,UAAAA,GAGKlQ,SAAS4R,cAAc,yBACtBzW,EAAQ0W,QAAQ,4BAClB1W,EAAQ0W,QAAQ,+BAIlBnC,EAAW7V,KAAKsB,GAEhBgI,EAAQ,CACNiB,KAAM,qBACNiM,KACAtU,KAAMb,EAAQC,KAGhBuV,EAAiBvV,GACnB,EACAgV,UAAAA,CAAW7P,GACT,SAASwR,IACPpC,EAAW8B,MACX,MAAMO,EAAiBpC,IAOvB,GALAxM,EAAQ,CACNiB,KAAM,qBACNiM,OAGE0B,EAAgB,CAClBrB,EAAiBqB,GACXnD,MAAAA,EAAiBf,EAAYK,IAAI6D,GACnCnD,GACFzL,EAAQ,CACNiB,KAAM,qBACNiM,GAAIzB,EAAeyB,GACnBtU,KAAMb,EAAQ6W,IACf,CAILf,EAAqB7V,EAAO,CAsBxB,MAAA6W,cAACA,GAAiB1R,EAClB2R,EAAY/I,EAAmB8I,GAC/BE,EAA8BtD,EAAeyC,SAASY,GAExDrJ,GAAAA,EAAcqJ,IAAcC,EAC9B,OApBF,SAASC,EAAiBhJ,GAClBiJ,MAAAA,EAAiB9R,IACf,MAAC0R,cAAAA,GAAiB1R,EACE4I,EAAmB8I,GAIlCA,GAAiBpJ,EAAcoJ,KACxC7I,EAAGR,oBAAoB,aAAcyJ,GACrCD,EAAiBH,KAJjB7I,EAAGR,oBAAoB,aAAcyJ,GACrCN,MAMDhO,EAAAA,iBAAiB,aAAcsO,EAA8B,CAQzDD,CAAiBF,GAGpBH,GAAA,GAIJzB,EAAKgC,IACLC,EAAa,CACjBjC,KACA9P,WACAC,SACAqP,SAAUsB,GAEDoB,EAAAA,IAAIpX,GACfiU,EAAgB2B,IAAIxE,EAAgBpR,GACpC6T,EAAa+B,IAAIV,EAAIlV,GACrB0S,EAAYkD,IAAI5V,EAASmX,GAEzB/C,GAAIgB,QAAQpV,GAEZgI,EAAQ,CACNiB,KAAM,mBACNiM,KACAlV,UACAY,KAAMb,EAAQC,GACdqF,SACAgS,eAAgBrX,EAAQ+J,aAAa,8BAGnC6J,GACFqB,EAAgBkC,EAAU,CAI9B,SAASG,GAAclS,SAACA,EAAAA,OAAUC,IAC1B,MAAArF,QAACA,GAAWoF,EACZqO,EAAiBf,EAAYK,IAAI/S,GAErC0S,IAAAA,EAAYkD,IAAI5V,EAAS,IAAIyT,EAAgBpO,WAC7C2C,EAAQ,CACNiB,KAAM,iBACNiM,GAAIzB,EAAeyB,GACnBtU,KAAMb,EAAQC,GACdqF,WACD,CAIL,SAASkS,EAAcrI,GACfyB,MAAAA,EAAcK,EAAgB9B,GACpC,IAAA,MAAWiI,KAAcxG,EAAa,CAC9B,MAAA3Q,QAACA,GAAWmX,EAAW/R,SACzBsN,EAAY8E,IAAIxX,GAClBsX,EAAcH,GAEdpB,EAAgBoB,EAAU,CAE9B,CAGF,SAASM,EAAkBzX,GACnByT,MAAAA,EAAiBf,EAAYK,IAAI/S,GACvC,GAAIyT,EAAgB,CACZ,MAAAyB,GAACA,EAAAA,SAAIR,GAAYjB,EACvBgB,EAAoBzU,EAAS0U,GAC7BP,EAAGmB,UAAUtV,GACb0S,EAAYgF,OAAO1X,GACnByS,EAAWiF,OAAO1X,GAClB6T,EAAa6D,OAAOxC,GACpBlN,EAAQ,CACNiB,KAAM,qBACNiM,MACD,CACH,CAGF,SAASyC,EAAeC,GACtB,IAAIC,GAAqB,EAMzB,IAAA,MAAWC,KAAYF,EAAW,CAC1B,MAAA7T,OAACA,EAAAA,KAAQkF,GAAQ6O,EAGjB5I,EAA6B,kBAATjG,EAA2BlF,EAAO+J,cAAgB/J,EAE/D0P,IAAAA,GAAkBA,EAAeyC,SAAShH,KAIvD2I,GAAqB,EACjBpK,EAAcyB,IAChBqI,EAAc,CAAClG,WAAY,CAACnC,KAAM,CAOlC2I,GAAAA,EACF,IAAA,MAAW7X,KAAWyS,EACPsF,EAAAA,aACXN,EAAkBzX,EAAO,CAMjC,SAASgY,EAAWhK,GACZyF,MAAAA,EAAiBf,EAAYK,IAAI/E,GACnCyF,GACFzL,EAAQ,CACNiB,KAAM,qBACNiM,GAAIzB,EAAeyB,GACnBtU,KAAMb,EAAQiO,IACf,CAIL,SAASiK,EAAaC,GACpB,IAAA,MAAWC,KAASD,EAAS,CAC3B,MAAMnU,EAASoU,EAAMpU,OAEjB0J,GAAAA,EAAc1J,GAAS,CACnB/D,MAAAA,EAAUiU,EAAgBlB,IAAIhP,GACpC,IAAK/D,EAAS,OACdgY,EAAWhY,EAAO,CACpB,CACF,CAGF,SAASoY,EAAmBF,GACrBtE,GAAAA,EACL,IAAA,MAAWuE,KAASD,EAAS,CACrB,MAAAnU,OAACA,GAAUoU,EACXE,EAAQ5K,EAAc1J,IAAW2O,EAAYK,IAAIhP,GAClDsU,IACDF,EAAMG,eACRrD,EAAgBoD,GAEhBhD,EAAkBgD,GAAK,CAE3B,CAGF,SAAS9K,EAAW0I,GACZjW,MAAAA,EAAU+N,EAAmBkI,EAAMlS,QAErC/D,EAC8C,YAA5CA,EAAQiO,QAAQC,uBAClB+H,EAAMhK,iBACNgK,EAAME,oBAKG5B,EAAA,GACbvM,EAAQ,CACNiB,KAAM,iBACP,CAGH,SAASsP,IACP,IAAA,MAAWvY,KAAWyS,EACpBuF,EAAWhY,EAAO,CAItB,SAASwY,EAAcvC,GACH,WAAdA,EAAM3I,MACRiH,EAAa,GACbvM,EAAQ,CACNiB,KAAM,iBACP,CAIL,SAASwP,EAAmBxC,GACpB,MAAAlS,OAACA,GAAUkS,EAEjB,GAAe7P,IAAAA,OAAOvB,UAAa4I,EAAc1J,GAIjD,IAAA,MAAW/D,KAAWyS,EAChB1O,EAAOmS,SAASlW,IAClBgY,EAAWhY,EAAO,CAKxB,SAAS0Y,IAEPtE,IAAAA,EAAK,IAAIuE,qBAAqBP,EAAoB,CAChDQ,UAAW,KAEbnG,EAAWoG,SAAS7Y,GAAYoU,EAAIgB,QAAQpV,KAC5CgI,EAAQ,CACNiB,KAAM,qBAER2K,GAAY,EAAA,CAGd,SAASkF,IACFlF,IACLQ,GAAI2E,aACJtG,EAAWoG,SAAqB7Y,IACxByT,MAAAA,EAAiBf,EAAYK,IAAI/S,GACnCyT,GACF4B,EAAkB5B,EAAc,IAGpCzL,EAAQ,CACNiB,KAAM,uBAER2K,GAAY,EAAA,CA6CdxN,OAAAA,OAAOvB,SAASmU,MAAMC,MAAMzN,MAAK,KAC/B,IAAA,MAAWxL,KAAWyS,EACpBuF,EAAWhY,EAAO,IAvBb2I,OAAAA,iBAAiB,QAAS4E,GACjCnH,OAAOuC,iBAAiB,cAAe4E,GACvCnH,OAAOuC,iBAAiB,UAAW6P,GACnCpS,OAAOuC,iBAAiB,SAAU4P,GAClCnS,OAAOuC,iBAAiB,SAAU8P,EAAoB,CACpD7D,SAAS,EACTsE,SAAS,IAEX/E,EAAK,IAAIgF,eAAelB,GACxB5D,EAAK,IAAI+E,iBAAiBzB,GAC1BtD,EAAGe,QAAQvQ,SAASC,KAAM,CACxBuU,YAAY,EACZC,eAAe,EACfC,WAAW,EACXC,SAAS,IAGXjC,EAAc1S,SAASC,MACvB4T,IAWK,CACLA,WACAI,aACAW,QArDF,WACErT,OAAOoH,oBAAoB,QAASD,GACpCnH,OAAOoH,oBAAoB,cAAeD,GAC1CnH,OAAOoH,oBAAoB,UAAWgL,GACtCpS,OAAOoH,oBAAoB,SAAU+K,GACrCnS,OAAOoH,oBAAoB,SAAUiL,GACrCpE,EAAG0E,aACH5E,EAAG4E,aAEHtG,EAAWoG,SAAqB7Y,IAC9ByX,EAAkBzX,EAAO,IAG3B6T,EAAa6F,QACbjH,EAAWiH,QAEXnF,EAAa,GACbuE,GAAW,EAsCf,ED3mBoFxF,QAAAqG,EAAAtH,EAAAiB,QAAAsG,EVD7Erb,SAAAsb,EAAAC,GAAA,MAAAC,EAAAC,EAAAA,EAAA,KAILC,EAAAC,GAAgCC,EAAAA,cAChCC,EAAAC,GAAoCF,EAAAA,SAAYN,IAChDS,EAAAC,GAAkCJ,kBAClCK,EAAAC,GAA8CN,EAAAA,SAAYN,GAE1Da,EAAcC,EAAAA,IAAoBC,IAAAA,SAAAd,GAShCc,EAAAA,CAAAC,EAAAC,KACmBC,MAAAC,QAAclB,GAAWA,EAAWA,CAAAA,IACtC3J,QAAA0C,CAAAA,EAAAoI,IAEXnB,EAAQjH,EAAG,CAAAhO,SACCgW,EAAMhW,SAAAqQ,GACZgG,EAAAA,EAAeL,EAAM3F,IAAIiG,WACjBN,EAAM3F,GAAAjM,KACZ4R,EAAM5R,QAEhB6R,GAEHf,KAAAD,EAAAC,KAAAa,GAAAA,EAAAb,EAAA,GAbHqB,MAAAA,EAA8BC,iBAC5BT,GAaD1Q,IAAAA,EAAA6P,OAAAF,GAM4C3P,EAAAA,IAAMuQ,EAAmBZ,GAAYE,KAAAF,EAAAE,KAAA7P,GAAAA,EAAA6P,EAAA,GAAlFuB,MAAAA,EAA8BD,iBAAenR,GAAsC,IAAAD,EAAAsR,EA8C1BC,EAAAC,EAAA1B,OA9C0BA,EAAAW,KAAAA,GAAAX,OAAAqB,GAAArB,EAAA,KAAAuB,GAOzErR,EAAAA,KAEJyR,GAAAA,EAAAA,EAAahB,GAAM,OASnBiB,IAAAA,EAEJ,MAAAC,EAAmBlB,EAAKmB,GAAI,iBAAeC,IACzC,MAAA7F,EAAA,CAAApR,SAEYiX,EAAMjX,SAAAqQ,GACZ4G,EAAM5G,GAAAiG,WACED,EAAAA,EAAeY,EAAM5G,IAAIjM,KAE/B,UAERoR,GAA6Be,GAAAA,EAAsBnF,EAAO6E,KAC1DP,EAAatE,GACbqF,IACApB,MAEA6B,aAAaJ,EAAe,IAE9BK,EAAoBtB,EAAKmB,GAAI,YAAU,KACrCF,EAAkBA,YAAA,KAEhBA,EAAAA,iBAAAA,IAAsBzB,GAAW,IAAM,GAAC,KAClC,IACR,MAAA,KAEU+B,EAAAA,cACVD,EAAWC,aAAa,CAAC,EAE1BV,EAACb,CAAAA,EAAOU,EAAuBE,GAAsBvB,KAAAW,EAAAX,KAAAqB,EAAArB,KAAAuB,EAAAvB,KAAA9P,EAAA8P,KAAAwB,IAAAtR,EAAA8P,EAAA,GAAAwB,EAAAxB,EAAA,IAvCxDmC,EAAAA,UAAUjS,EAuCPsR,GAAsDxB,EAAAO,KAAAA,GAAAP,EAAA,MAAAS,GAAAT,EAAAF,MAAAA,GAAAE,EAAA,MAAAE,GAAAF,QAAAqB,GAM/CI,EAAAA,KAAA,IACIvB,EAAA,CAAA,IAIPK,EAASpb,MAAAA,IAAAA,MAEI,gDAEM2a,IAAAA,GAMxBsC,EAAAA,iBAAA,KACE9B,EAAce,EAAsBd,EAAWT,IAC/CY,EAAmBZ,EAAW,GAC/B,GACA4B,EAAA,CAACnB,EAAWE,EAAiBX,EAAaI,EAAUmB,GAAsBrB,KAAAO,EAAAP,MAAAS,EAAAT,MAAAF,EAAAE,MAAAE,EAAAF,MAAAqB,EAAArB,MAAAyB,EAAAzB,MAAA0B,IAAAD,EAAAzB,EAAA,IAAA0B,EAAA1B,EAAA,KAnB7EmC,EAAAA,UAAUV,EAmBPC,GAEIxB,EAAWJ,EAAcO,CAAU","x_google_ignoreList":[1,2,3,4]}