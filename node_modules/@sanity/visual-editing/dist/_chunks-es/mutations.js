import{c as t}from"react-compiler-runtime";import{createIfNotExists as n,patch as e,at as r,insert as o,truncate as s}from"@sanity/mutate";import{e as i,a as u,l as a,i as f}from"./context.js";import{D as c}from"./transformSanityNodeData.js";import{useSyncExternalStore as p}from"react";import d from"get-random-values-esm";const y=/_key\s*==\s*['"](.*)['"]/,h=/^\d*:\d*$/;function m(t){return"number"==typeof t||"string"==typeof t&&/^\[\d+\]$/.test(t)}function l(t){return"string"==typeof t?y.test(t.trim()):"object"==typeof t&&"_key"in t}const g=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,b=/_key\s*==\s*['"](.*)['"]/;function w(t,n,e){const r="string"==typeof n?function(t){if("string"!=typeof t)throw new Error("Path is not a string");const n=t.match(g);if(!n)throw new Error("Invalid path string");return n.map(k)}(n):n;if(!Array.isArray(r))throw new Error("Path must be an array or a string");let o=t;for(let t=0;t<r.length;t++){const n=r[t];if(m(n)){if(!Array.isArray(o))return e;o=o[n]}if(l(n)){if(!Array.isArray(o))return e;o=o.find((t=>t._key===n._key))}if("string"==typeof n&&(o="object"==typeof o&&null!==o?o[n]:void 0),typeof o>"u")return e}return o}function k(t){return m(t)?function(t){return Number(t.replace(/[^\d]/g,""))}(t):l(t)?function(t){return{_key:t.match(b)[1]}}(t):function(t){if("string"==typeof t&&h.test(t))return!0;if(!Array.isArray(t)||2!==t.length)return!1;const[n,e]=t;return!("number"!=typeof n&&""!==n||"number"!=typeof e&&""!==e)}(t)?function(t){const[n,e]=t.split(":").map((t=>""===t?t:Number(t)));return[n,e]}(t):t}function x(t){return t.startsWith(c)}function _(t){return x(t)?t:c+t}function I(t){return x(t)?t.slice(c.length):t}function S(){return p(A,E,D)}function D(){return i}function E(){return u}function A(t){return a.add(t),()=>a.delete(t)}function j(){const t=S();let n;return n=!f(t),n}function v(t,n){let e;return(...r)=>{clearTimeout(e),e=setTimeout((()=>{t.apply(t,r)}),n)}}function O(t,n){const e=window.self!==window.top||window.opener;if(f(n)||!e)throw new Error("The `useDocuments` hook cannot be used in this context");const r=_(t),o=I(t),s=n.getSnapshot().context?.documents,i=s?.[r],u=s?.[o],a=i||u;if(!a)throw new Error(`Document "${t}" not found`);const c=i.getSnapshot().context?.local||u.getSnapshot().context?.local,p=new Promise((t=>{if(c)t(c);else{const n=a.on("ready",(e=>{const{snapshot:r}=e;t(r||null),n.unsubscribe()}))}}));return{draftDoc:i,draftId:r,getSnapshot:()=>p,publishedDoc:u,publishedId:o,get snapshot(){if(!c)throw new Error(`Snapshot for document "${t}" not found`);return c}}}function $(t,n){return()=>{const{draftDoc:e}=O(t,n);e.send({type:"submit"})}}function N(t,n){return e=>{const{snapshot:r}=O(t,n);return e?w(r,e):r}}function P(t,n){const{getSnapshot:e}=O(t,n);return e}function T(t,r){return async(o,s)=>{const i=O(t,r),{draftDoc:u,draftId:a,getSnapshot:f,publishedId:c}=i,{commit:p=!0}=s||{},d=await("function"==typeof o?o({draftId:a,publishedId:c,get snapshot(){return i.snapshot},getSnapshot:f}):o),y=await f();if(!y)throw new Error(`Snapshot for document "${t}" not found`);u.send({type:"mutate",mutations:[n({...y,_id:a}),e(a,d)]}),p&&("object"==typeof p&&"debounce"in p?v((()=>u.send({type:"submit"})),p.debounce)():u.send({type:"submit"}))}}function K(){const n=t(7),e=S();let r;n[0]!==e?(r=t=>({id:t,commit:$(t,e),get:N(t,e),getSnapshot:P(t,e),patch:T(t,e)}),n[0]=e,n[1]=r):r=n[1];const o=r;let s;n[2]!==e?(s=(t,n,r)=>{const{draftDoc:o}=O(t,e),{commit:s}=r||{},i=void 0===s||s;o.send({type:"mutate",mutations:n}),i&&("object"==typeof i&&"debounce"in i?v((()=>o.send({type:"submit"})),i.debounce)():o.send({type:"submit"}))},n[2]=e,n[3]=s):s=n[3];const i=s;let u;return n[4]!==o||n[5]!==i?(u={getDocument:o,mutateDocument:i},n[4]=o,n[5]=i,n[6]=u):u=n[6],u}const U=(()=>{let t;return()=>{if(t)return t;t=[];for(let n=0;n<256;++n)t[n]=(n+256).toString(16).slice(1);return t}})();function W(t){const n=U();return function(t=16){const n=new Uint8Array(t);return d(n),n}(t).reduce(((t,e)=>t+n[e]),"").slice(0,t)}function q(t){const n="string"==typeof t?t:t.path,e=n.lastIndexOf("."),r=n.substring(e+1,n.length);if(!r.indexOf("["))throw new Error("Invalid path: not an array");const o=n.lastIndexOf("["),s=n.substring(0,o);let i,u;if(r.includes("_key")){const t=r.indexOf('"')+1,n=r.indexOf('"',t);i=r.substring(t,n),u=!0}else{const t=r.indexOf("[")+1,n=r.indexOf("]",t);i=r.substring(t,n),u=!1}if(!s||!i)throw new Error("Invalid path");return{path:s,key:i,hasExplicitKey:u}}function z(t,n,e="after"){const{path:s,key:i}=q(t),u={...w(n,t.path),_key:W()};return[r(s,o(u,e,{_key:i}))]}function B(t,n){const{path:e,key:o}=q(t),i=w(n,e).findIndex((t=>t._key===o));return[r(e,s(i,i+1))]}function C(t,n,e){const{path:s,key:i}=q(t),u=W();return[r(s,o([{_type:n,_key:u}],e,{_key:i}))]}async function F(t,n,e){if(!t.type)throw new Error("Node type is missing");const{path:i,key:u}=q(t),a=await n.getSnapshot(),f=w(a,i),c=w(a,t.path),p=f.findIndex((t=>t._key===u));let d=-1,y="before";if("first"===e){if(0===p)return[];d=0,y="before"}else if("last"===e){if(p===f.length-1)return[];d=-1,y="after"}else if("next"===e){if(p===f.length-1)return[];d=p,y="after"}else if("previous"===e){if(0===p)return[];d=p-1,y="before"}return[r(i,s(p,p+1)),r(i,o(c,y,d))]}export{C as a,S as b,I as c,w as d,F as e,B as f,q as g,z as h,j as i,_ as j,K as u};//# sourceMappingURL=mutations.js.map
