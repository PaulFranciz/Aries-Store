"use strict";
var util_getBlockStartPoint = require("./util.get-block-start-point.cjs"), util_isKeyedSegment = require("./util.is-keyed-segment.cjs"), types = require("@sanity/types");
const getSelectionText = ({
  context
}) => {
  let text = "";
  const {
    value,
    selection
  } = context;
  if (!value || !selection)
    return text;
  const forwardSelection = selection.backward ? util_getBlockStartPoint.reverseSelection(selection) : selection;
  if (!forwardSelection)
    return text;
  for (const block of value)
    if (!(util_isKeyedSegment.isKeyedSegment(forwardSelection.anchor.path[0]) && block._key !== forwardSelection.anchor.path[0]._key) && types.isPortableTextTextBlock(block)) {
      for (const child of block.children)
        if (types.isPortableTextSpan(child)) {
          if (util_isKeyedSegment.isKeyedSegment(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key && util_isKeyedSegment.isKeyedSegment(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {
            text = text + child.text.slice(forwardSelection.anchor.offset, forwardSelection.focus.offset);
            break;
          }
          if (util_isKeyedSegment.isKeyedSegment(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key) {
            text = text + child.text.slice(forwardSelection.anchor.offset);
            continue;
          }
          if (util_isKeyedSegment.isKeyedSegment(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {
            text = text + child.text.slice(0, forwardSelection.focus.offset);
            break;
          }
          text.length > 0 && (text = text + child.text);
        }
      if (util_isKeyedSegment.isKeyedSegment(forwardSelection.focus.path[0]) && block._key === forwardSelection.focus.path[0]._key)
        break;
    }
  return text;
}, getBlockTextBefore = ({
  context
}) => {
  if (!context.selection)
    return "";
  const point = (context.selection.backward ? util_getBlockStartPoint.reverseSelection(context.selection) : context.selection).anchor, key = util_isKeyedSegment.isKeyedSegment(point.path[0]) ? point.path[0]._key : void 0, block = key ? context.value.find((block2) => block2._key === key) : void 0;
  if (!block)
    return "";
  const startOfBlock = util_getBlockStartPoint.getBlockStartPoint({
    node: block,
    path: [{
      _key: block._key
    }]
  });
  return getSelectionText({
    context: {
      ...context,
      value: context.value,
      selection: {
        anchor: startOfBlock,
        focus: point
      }
    }
  });
};
exports.getBlockTextBefore = getBlockTextBefore;
exports.getSelectionText = getSelectionText;
//# sourceMappingURL=selector.get-text-before.cjs.map
